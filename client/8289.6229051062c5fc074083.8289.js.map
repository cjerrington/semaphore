{"version":3,"file":"8289.6229051062c5fc074083.8289.js","mappings":"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","sources":["webpack://semaphore/./node_modules/emoji-picker-element/database.js"],"sourcesContent":["function assertNonEmptyString (str) {\n  if (typeof str !== 'string' || !str) {\n    throw new Error('expected a non-empty string, got: ' + str)\n  }\n}\n\nfunction assertNumber (number) {\n  if (typeof number !== 'number') {\n    throw new Error('expected a number, got: ' + number)\n  }\n}\n\nconst DB_VERSION_CURRENT = 1;\nconst DB_VERSION_INITIAL = 1;\nconst STORE_EMOJI = 'emoji';\nconst STORE_KEYVALUE = 'keyvalue';\nconst STORE_FAVORITES = 'favorites';\nconst FIELD_TOKENS = 'tokens';\nconst INDEX_TOKENS = 'tokens';\nconst FIELD_UNICODE = 'unicode';\nconst INDEX_COUNT = 'count';\nconst FIELD_GROUP = 'group';\nconst FIELD_ORDER = 'order';\nconst INDEX_GROUP_AND_ORDER = 'group-order';\nconst KEY_ETAG = 'eTag';\nconst KEY_URL = 'url';\nconst KEY_PREFERRED_SKINTONE = 'skinTone';\nconst MODE_READONLY = 'readonly';\nconst MODE_READWRITE = 'readwrite';\nconst INDEX_SKIN_UNICODE = 'skinUnicodes';\nconst FIELD_SKIN_UNICODE = 'skinUnicodes';\n\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json';\nconst DEFAULT_LOCALE = 'en';\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy (arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res\n}\n\nfunction uniqEmoji (emojis) {\n  return uniqBy(emojis, _ => _.unicode)\n}\n\nfunction initialMigration (db) {\n  function createObjectStore (name, keyPath, indexes) {\n    const store = keyPath\n      ? db.createObjectStore(name, { keyPath })\n      : db.createObjectStore(name);\n    if (indexes) {\n      for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes)) {\n        store.createIndex(indexName, keyPath, { multiEntry });\n      }\n    }\n    return store\n  }\n\n  createObjectStore(STORE_KEYVALUE);\n  createObjectStore(STORE_EMOJI, /* keyPath */ FIELD_UNICODE, {\n    [INDEX_TOKENS]: [FIELD_TOKENS, /* multiEntry */ true],\n    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],\n    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, /* multiEntry */ true]\n  });\n  createObjectStore(STORE_FAVORITES, undefined, {\n    [INDEX_COUNT]: ['']\n  });\n}\n\nconst openReqs = {};\nconst databaseCache = {};\nconst onCloseListeners = {};\n\nfunction handleOpenOrDeleteReq (resolve, reject, req) {\n  // These things are almost impossible to test with fakeIndexedDB sadly\n  /* istanbul ignore next */\n  req.onerror = () => reject(req.error);\n  /* istanbul ignore next */\n  req.onblocked = () => reject(new Error('IDB blocked'));\n  req.onsuccess = () => resolve(req.result);\n}\n\nasync function createDatabase (dbName) {\n  const db = await new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);\n    openReqs[dbName] = req;\n    req.onupgradeneeded = e => {\n      // Technically there is only one version, so we don't need this `if` check\n      // But if an old version of the JS is in another browser tab\n      // and it gets upgraded in the future and we have a new DB version, well...\n      // better safe than sorry.\n      /* istanbul ignore else */\n      if (e.oldVersion < DB_VERSION_INITIAL) {\n        initialMigration(req.result);\n      }\n    };\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n  // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n  // No need for removeEventListener, because once the DB can no longer\n  // fire \"close\" events, it will auto-GC.\n  // Unfortunately cannot test in fakeIndexedDB: https://github.com/dumbmatter/fakeIndexedDB/issues/50\n  /* istanbul ignore next */\n  db.onclose = () => closeDatabase(dbName);\n  return db\n}\n\nfunction openDatabase (dbName) {\n  if (!databaseCache[dbName]) {\n    databaseCache[dbName] = createDatabase(dbName);\n  }\n  return databaseCache[dbName]\n}\n\nfunction dbPromise (db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    // Use relaxed durability because neither the emoji data nor the favorites/preferred skin tone\n    // are really irreplaceable data. IndexedDB is just a cache in this case.\n    const txn = db.transaction(storeName, readOnlyOrReadWrite, { durability: 'relaxed' });\n    const store = typeof storeName === 'string'\n      ? txn.objectStore(storeName)\n      : storeName.map(name => txn.objectStore(name));\n    let res;\n    cb(store, txn, (result) => {\n      res = result;\n    });\n\n    txn.oncomplete = () => resolve(res);\n    /* istanbul ignore next */\n    txn.onerror = () => reject(txn.error);\n  })\n}\n\nfunction closeDatabase (dbName) {\n  // close any open requests\n  const req = openReqs[dbName];\n  const db = req && req.result;\n  if (db) {\n    db.close();\n    const listeners = onCloseListeners[dbName];\n    /* istanbul ignore else */\n    if (listeners) {\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  }\n  delete openReqs[dbName];\n  delete databaseCache[dbName];\n  delete onCloseListeners[dbName];\n}\n\nfunction deleteDatabase (dbName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    closeDatabase(dbName);\n    const req = indexedDB.deleteDatabase(dbName);\n    handleOpenOrDeleteReq(resolve, reject, req);\n  })\n}\n\n// The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\nfunction addOnCloseListener (dbName, listener) {\n  let listeners = onCloseListeners[dbName];\n  if (!listeners) {\n    listeners = onCloseListeners[dbName] = [];\n  }\n  listeners.push(listener);\n}\n\n// list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emoji-picker-element-data/en/emojibase/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\nconst irregularEmoticons = new Set([\n  ':D', 'XD', \":'D\", 'O:)',\n  ':X', ':P', ';P', 'XP',\n  ':L', ':Z', ':j', '8D',\n  'XO', '8)', ':B', ':O',\n  ':S', \":'o\", 'Dx', 'X(',\n  'D:', ':C', '>0)', ':3',\n  '</3', '<3', '\\\\M/', ':E',\n  '8#'\n]);\n\nfunction extractTokens (str) {\n  return str\n    .split(/[\\s_]+/)\n    .map(word => {\n      if (!word.match(/\\w/) || irregularEmoticons.has(word)) {\n        // for pure emoticons like :) or :-), just leave them as-is\n        return word.toLowerCase()\n      }\n\n      return word\n        .replace(/[)(:,]/g, '')\n        .replace(/’/g, \"'\")\n        .toLowerCase()\n    }).filter(Boolean)\n}\n\nconst MIN_SEARCH_TEXT_LENGTH = 2;\n\n// This is an extra step in addition to extractTokens(). The difference here is that we expect\n// the input to have already been run through extractTokens(). This is useful for cases like\n// emoticons, where we don't want to do any tokenization (because it makes no sense to split up\n// \">:)\" by the colon) but we do want to lowercase it to have consistent search results, so that\n// the user can type ':P' or ':p' and still get the same result.\nfunction normalizeTokens (str) {\n  return str\n    .filter(Boolean)\n    .map(_ => _.toLowerCase())\n    .filter(_ => _.length >= MIN_SEARCH_TEXT_LENGTH)\n}\n\n// Transform emoji data for storage in IDB\nfunction transformEmojiData (emojiData) {\n  const res = emojiData.map(({ annotation, emoticon, group, order, shortcodes, skins, tags, emoji, version }) => {\n    const tokens = [...new Set(\n      normalizeTokens([\n        ...(shortcodes || []).map(extractTokens).flat(),\n        ...tags.map(extractTokens).flat(),\n        ...extractTokens(annotation),\n        emoticon\n      ])\n    )].sort();\n    const res = {\n      annotation,\n      group,\n      order,\n      tags,\n      tokens,\n      unicode: emoji,\n      version\n    };\n    if (emoticon) {\n      res.emoticon = emoticon;\n    }\n    if (shortcodes) {\n      res.shortcodes = shortcodes;\n    }\n    if (skins) {\n      res.skinTones = [];\n      res.skinUnicodes = [];\n      res.skinVersions = [];\n      for (const { tone, emoji, version } of skins) {\n        res.skinTones.push(tone);\n        res.skinUnicodes.push(emoji);\n        res.skinVersions.push(version);\n      }\n    }\n    return res\n  });\n  return res\n}\n\n// helper functions that help compress the code better\n\nfunction callStore (store, method, key, cb) {\n  store[method](key).onsuccess = e => (cb && cb(e.target.result));\n}\n\nfunction getIDB (store, key, cb) {\n  callStore(store, 'get', key, cb);\n}\n\nfunction getAllIDB (store, key, cb) {\n  callStore(store, 'getAll', key, cb);\n}\n\nfunction commit (txn) {\n  /* istanbul ignore else */\n  if (txn.commit) {\n    txn.commit();\n  }\n}\n\n// like lodash's minBy\nfunction minBy (array, func) {\n  let minItem = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (func(minItem) > func(item)) {\n      minItem = item;\n    }\n  }\n  return minItem\n}\n\n// return an array of results representing all items that are found in each one of the arrays\n\nfunction findCommonMembers (arrays, uniqByFunc) {\n  const shortestArray = minBy(arrays, _ => _.length);\n  const results = [];\n  for (const item of shortestArray) {\n    // if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some(array => array.findIndex(_ => uniqByFunc(_) === uniqByFunc(item)) === -1)) {\n      results.push(item);\n    }\n  }\n  return results\n}\n\nasync function isEmpty (db) {\n  return !(await get(db, STORE_KEYVALUE, KEY_URL))\n}\n\nasync function hasData (db, url, eTag) {\n  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL]\n    .map(key => get(db, STORE_KEYVALUE, key)));\n  return (oldETag === eTag && oldUrl === url)\n}\n\nasync function doFullDatabaseScanForSingleResult (db, predicate) {\n  // This batching algorithm is just a perf improvement over a basic\n  // cursor. The BATCH_SIZE is an estimate of what would give the best\n  // perf for doing a full DB scan (worst case).\n  //\n  // Mini-benchmark for determining the best batch size:\n  //\n  // PERF=1 yarn build:rollup && yarn test:adhoc\n  //\n  // (async () => {\n  //   performance.mark('start')\n  //   await $('emoji-picker').database.getEmojiByShortcode('doesnotexist')\n  //   performance.measure('total', 'start')\n  //   console.log(performance.getEntriesByName('total').slice(-1)[0].duration)\n  // })()\n  const BATCH_SIZE = 50; // Typically around 150ms for 6x slowdown in Chrome for above benchmark\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    let lastKey;\n\n    const processNextBatch = () => {\n      emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = e => {\n        const results = e.target.result;\n        for (const result of results) {\n          lastKey = result.unicode;\n          if (predicate(result)) {\n            return cb(result)\n          }\n        }\n        if (results.length < BATCH_SIZE) {\n          return cb()\n        }\n        processNextBatch();\n      };\n    };\n    processNextBatch();\n  })\n}\n\nasync function loadData (db, emojiData, url, eTag) {\n  try {\n    const transformedData = transformEmojiData(emojiData);\n    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, ([emojiStore, metaStore], txn) => {\n      let oldETag;\n      let oldUrl;\n      let todo = 0;\n\n      function checkFetched () {\n        if (++todo === 2) { // 2 requests made\n          onFetched();\n        }\n      }\n\n      function onFetched () {\n        if (oldETag === eTag && oldUrl === url) {\n          // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n          return\n        }\n        // delete old data\n        emojiStore.clear();\n        // insert new data\n        for (const data of transformedData) {\n          emojiStore.put(data);\n        }\n        metaStore.put(eTag, KEY_ETAG);\n        metaStore.put(url, KEY_URL);\n        commit(txn);\n      }\n\n      getIDB(metaStore, KEY_ETAG, result => {\n        oldETag = result;\n        checkFetched();\n      });\n\n      getIDB(metaStore, KEY_URL, result => {\n        oldUrl = result;\n        checkFetched();\n      });\n    });\n  } finally {\n  }\n}\n\nasync function getEmojiByGroup (db, group) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);\n    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);\n  })\n}\n\nasync function getEmojiBySearchQuery (db, query) {\n  const tokens = normalizeTokens(extractTokens(query));\n\n  if (!tokens.length) {\n    return []\n  }\n\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    // get all results that contain all tokens (i.e. an AND query)\n    const intermediateResults = [];\n\n    const checkDone = () => {\n      if (intermediateResults.length === tokens.length) {\n        onDone();\n      }\n    };\n\n    const onDone = () => {\n      const results = findCommonMembers(intermediateResults, _ => _.unicode);\n      cb(results.sort((a, b) => a.order < b.order ? -1 : 1));\n    };\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const range = i === tokens.length - 1\n        ? IDBKeyRange.bound(token, token + '\\uffff', false, true) // treat last token as a prefix search\n        : IDBKeyRange.only(token); // treat all other tokens as an exact match\n      getAllIDB(emojiStore.index(INDEX_TOKENS), range, result => {\n        intermediateResults.push(result);\n        checkDone();\n      });\n    }\n  })\n}\n\n// This could have been implemented as an IDB index on shortcodes, but it seemed wasteful to do that\n// when we can already query by tokens and this will give us what we're looking for 99.9% of the time\nasync function getEmojiByShortcode (db, shortcode) {\n  const emojis = await getEmojiBySearchQuery(db, shortcode);\n\n  // In very rare cases (e.g. the shortcode \"v\" as in \"v for victory\"), we cannot search because\n  // there are no usable tokens (too short in this case). In that case, we have to do an inefficient\n  // full-database scan, which I believe is an acceptable tradeoff for not having to have an extra\n  // index on shortcodes.\n\n  if (!emojis.length) {\n    const predicate = _ => ((_.shortcodes || []).includes(shortcode.toLowerCase()));\n    return (await doFullDatabaseScanForSingleResult(db, predicate)) || null\n  }\n\n  return emojis.filter(_ => {\n    const lowerShortcodes = (_.shortcodes || []).map(_ => _.toLowerCase());\n    return lowerShortcodes.includes(shortcode.toLowerCase())\n  })[0] || null\n}\n\nasync function getEmojiByUnicode (db, unicode) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => (\n    getIDB(emojiStore, unicode, result => {\n      if (result) {\n        return cb(result)\n      }\n      getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, result => cb(result || null));\n    })\n  ))\n}\n\nfunction get (db, storeName, key) {\n  return dbPromise(db, storeName, MODE_READONLY, (store, txn, cb) => (\n    getIDB(store, key, cb)\n  ))\n}\n\nfunction set (db, storeName, key, value) {\n  return dbPromise(db, storeName, MODE_READWRITE, (store, txn) => {\n    store.put(value, key);\n    commit(txn);\n  })\n}\n\nfunction incrementFavoriteEmojiCount (db, unicode) {\n  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store, txn) => (\n    getIDB(store, unicode, result => {\n      store.put((result || 0) + 1, unicode);\n      commit(txn);\n    })\n  ))\n}\n\nfunction getTopFavoriteEmoji (db, customEmojiIndex, limit) {\n  if (limit === 0) {\n    return []\n  }\n  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, ([favoritesStore, emojiStore], txn, cb) => {\n    const results = [];\n    favoritesStore.index(INDEX_COUNT).openCursor(undefined, 'prev').onsuccess = e => {\n      const cursor = e.target.result;\n      if (!cursor) { // no more results\n        return cb(results)\n      }\n\n      function addResult (result) {\n        results.push(result);\n        if (results.length === limit) {\n          return cb(results) // done, reached the limit\n        }\n        cursor.continue();\n      }\n\n      const unicodeOrName = cursor.primaryKey;\n      const custom = customEmojiIndex.byName(unicodeOrName);\n      if (custom) {\n        return addResult(custom)\n      }\n      // This could be done in parallel (i.e. make the cursor and the get()s parallelized),\n      // but my testing suggests it's not actually faster.\n      getIDB(emojiStore, unicodeOrName, emoji => {\n        if (emoji) {\n          return addResult(emoji)\n        }\n        // emoji not found somehow, ignore (may happen if custom emoji change)\n        cursor.continue();\n      });\n    };\n  })\n}\n\n// trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\n\nconst CODA_MARKER = ''; // marks the end of the string\n\nfunction trie (arr, itemToTokens) {\n  const map = new Map();\n  for (const item of arr) {\n    const tokens = itemToTokens(item);\n    for (const token of tokens) {\n      let currentMap = map;\n      for (let i = 0; i < token.length; i++) {\n        const char = token.charAt(i);\n        let nextMap = currentMap.get(char);\n        if (!nextMap) {\n          nextMap = new Map();\n          currentMap.set(char, nextMap);\n        }\n        currentMap = nextMap;\n      }\n      let valuesAtCoda = currentMap.get(CODA_MARKER);\n      if (!valuesAtCoda) {\n        valuesAtCoda = [];\n        currentMap.set(CODA_MARKER, valuesAtCoda);\n      }\n      valuesAtCoda.push(item);\n    }\n  }\n\n  const search = (query, exact) => {\n    let currentMap = map;\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charAt(i);\n      const nextMap = currentMap.get(char);\n      if (nextMap) {\n        currentMap = nextMap;\n      } else {\n        return []\n      }\n    }\n\n    if (exact) {\n      const results = currentMap.get(CODA_MARKER);\n      return results || []\n    }\n\n    const results = [];\n    // traverse\n    const queue = [currentMap];\n    while (queue.length) {\n      const currentMap = queue.shift();\n      const entriesSortedByKey = [...currentMap.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);\n      for (const [key, value] of entriesSortedByKey) {\n        if (key === CODA_MARKER) { // CODA_MARKER always comes first; it's the empty string\n          results.push(...value);\n        } else {\n          queue.push(value);\n        }\n      }\n    }\n    return results\n  };\n\n  return search\n}\n\nconst requiredKeys$1 = [\n  'name',\n  'url'\n];\n\nfunction assertCustomEmojis (customEmojis) {\n  const isArray = customEmojis && Array.isArray(customEmojis);\n  const firstItemIsFaulty = isArray &&\n    customEmojis.length &&\n    (!customEmojis[0] || requiredKeys$1.some(key => !(key in customEmojis[0])));\n  if (!isArray || firstItemIsFaulty) {\n    throw new Error('Custom emojis are in the wrong format')\n  }\n}\n\nfunction customEmojiIndex (customEmojis) {\n  assertCustomEmojis(customEmojis);\n\n  const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;\n\n  //\n  // all()\n  //\n  const all = customEmojis.sort(sortByName);\n\n  //\n  // search()\n  //\n  const emojiToTokens = emoji => (\n    [...new Set((emoji.shortcodes || []).map(shortcode => extractTokens(shortcode)).flat())]\n  );\n  const searchTrie = trie(customEmojis, emojiToTokens);\n  const searchByExactMatch = _ => searchTrie(_, true);\n  const searchByPrefix = _ => searchTrie(_, false);\n\n  // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n  // is treated as a prefix search, but every other one is treated as an exact match.\n  // Then we AND the results together\n  const search = query => {\n    const tokens = extractTokens(query);\n    const intermediateResults = tokens.map((token, i) => (\n      (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token)\n    ));\n    return findCommonMembers(intermediateResults, _ => _.name).sort(sortByName)\n  };\n\n  //\n  // byShortcode, byName\n  //\n  const shortcodeToEmoji = new Map();\n  const nameToEmoji = new Map();\n  for (const customEmoji of customEmojis) {\n    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n    for (const shortcode of (customEmoji.shortcodes || [])) {\n      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n  }\n\n  const byShortcode = shortcode => shortcodeToEmoji.get(shortcode.toLowerCase());\n  const byName = name => nameToEmoji.get(name.toLowerCase());\n\n  return {\n    all,\n    search,\n    byShortcode,\n    byName\n  }\n}\n\n// remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\nfunction cleanEmoji (emoji) {\n  if (!emoji) {\n    return emoji\n  }\n  delete emoji.tokens;\n  if (emoji.skinTones) {\n    const len = emoji.skinTones.length;\n    emoji.skins = Array(len);\n    for (let i = 0; i < len; i++) {\n      emoji.skins[i] = {\n        tone: emoji.skinTones[i],\n        unicode: emoji.skinUnicodes[i],\n        version: emoji.skinVersions[i]\n      };\n    }\n    delete emoji.skinTones;\n    delete emoji.skinUnicodes;\n    delete emoji.skinVersions;\n  }\n  return emoji\n}\n\nfunction warnETag (eTag) {\n  if (!eTag) {\n    console.warn('emoji-picker-element is more efficient if the dataSource server exposes an ETag header.');\n  }\n}\n\nconst requiredKeys = [\n  'annotation',\n  'emoji',\n  'group',\n  'order',\n  'tags',\n  'version'\n];\n\nfunction assertEmojiData (emojiData) {\n  if (!emojiData ||\n    !Array.isArray(emojiData) ||\n    !emojiData[0] ||\n    (typeof emojiData[0] !== 'object') ||\n    requiredKeys.some(key => (!(key in emojiData[0])))) {\n    throw new Error('Emoji data is in the wrong format')\n  }\n}\n\nfunction assertStatus (response, dataSource) {\n  if (Math.floor(response.status / 100) !== 2) {\n    throw new Error('Failed to fetch: ' + dataSource + ':  ' + response.status)\n  }\n}\n\nasync function getETag (dataSource) {\n  const response = await fetch(dataSource, { method: 'HEAD' });\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  return eTag\n}\n\nasync function getETagAndData (dataSource) {\n  const response = await fetch(dataSource);\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  const emojiData = await response.json();\n  assertEmojiData(emojiData);\n  return [eTag, emojiData]\n}\n\n// TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n/**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */\nfunction arrayBufferToBinaryString(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    var length = bytes.byteLength;\n    var i = -1;\n    while (++i < length) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */\nfunction binaryStringToArrayBuffer(binary) {\n    var length = binary.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    var i = -1;\n    while (++i < length) {\n        arr[i] = binary.charCodeAt(i);\n    }\n    return buf;\n}\n\n// generate a checksum based on the stringified JSON\nasync function jsonChecksum (object) {\n  const inString = JSON.stringify(object);\n  const inBuffer = binaryStringToArrayBuffer(inString);\n  // this does not need to be cryptographically secure, SHA-1 is fine\n  const outBuffer = await crypto.subtle.digest('SHA-1', inBuffer);\n  const outBinString = arrayBufferToBinaryString(outBuffer);\n  const res = btoa(outBinString);\n  return res\n}\n\nasync function checkForUpdates (db, dataSource) {\n  // just do a simple HEAD request first to see if the eTags match\n  let emojiData;\n  let eTag = await getETag(dataSource);\n  if (!eTag) { // work around lack of ETag/Access-Control-Expose-Headers\n    const eTagAndData = await getETagAndData(dataSource);\n    eTag = eTagAndData[0];\n    emojiData = eTagAndData[1];\n    if (!eTag) {\n      eTag = await jsonChecksum(emojiData);\n    }\n  }\n  if (await hasData(db, dataSource, eTag)) ; else {\n    if (!emojiData) {\n      const eTagAndData = await getETagAndData(dataSource);\n      emojiData = eTagAndData[1];\n    }\n    await loadData(db, emojiData, dataSource, eTag);\n  }\n}\n\nasync function loadDataForFirstTime (db, dataSource) {\n  let [eTag, emojiData] = await getETagAndData(dataSource);\n  if (!eTag) {\n    // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await jsonChecksum(emojiData);\n  }\n\n  await loadData(db, emojiData, dataSource, eTag);\n}\n\nclass Database {\n  constructor ({ dataSource = DEFAULT_DATA_SOURCE, locale = DEFAULT_LOCALE, customEmoji = [] } = {}) {\n    this.dataSource = dataSource;\n    this.locale = locale;\n    this._dbName = `emoji-picker-element-${this.locale}`;\n    this._db = undefined;\n    this._lazyUpdate = undefined;\n    this._custom = customEmojiIndex(customEmoji);\n\n    this._clear = this._clear.bind(this);\n    this._ready = this._init();\n  }\n\n  async _init () {\n    const db = this._db = await openDatabase(this._dbName);\n\n    addOnCloseListener(this._dbName, this._clear);\n    const dataSource = this.dataSource;\n    const empty = await isEmpty(db);\n\n    if (empty) {\n      await loadDataForFirstTime(db, dataSource);\n    } else { // offline-first - do an update asynchronously\n      this._lazyUpdate = checkForUpdates(db, dataSource);\n    }\n  }\n\n  async ready () {\n    const checkReady = async () => {\n      if (!this._ready) {\n        this._ready = this._init();\n      }\n      return this._ready\n    };\n    await checkReady();\n    // There's a possibility of a race condition where the element gets added, removed, and then added again\n    // with a particular timing, which would set the _db to undefined.\n    // We *could* do a while loop here, but that seems excessive and could lead to an infinite loop.\n    if (!this._db) {\n      await checkReady();\n    }\n  }\n\n  async getEmojiByGroup (group) {\n    assertNumber(group);\n    await this.ready();\n    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji)\n  }\n\n  async getEmojiBySearchQuery (query) {\n    assertNonEmptyString(query);\n    await this.ready();\n    const customs = this._custom.search(query);\n    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);\n    return [\n      ...customs,\n      ...natives\n    ]\n  }\n\n  async getEmojiByShortcode (shortcode) {\n    assertNonEmptyString(shortcode);\n    await this.ready();\n    const custom = this._custom.byShortcode(shortcode);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode))\n  }\n\n  async getEmojiByUnicodeOrName (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    const custom = this._custom.byName(unicodeOrName);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName))\n  }\n\n  async getPreferredSkinTone () {\n    await this.ready();\n    return (await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE)) || 0\n  }\n\n  async setPreferredSkinTone (skinTone) {\n    assertNumber(skinTone);\n    await this.ready();\n    return set(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone)\n  }\n\n  async incrementFavoriteEmojiCount (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    return incrementFavoriteEmojiCount(this._db, unicodeOrName)\n  }\n\n  async getTopFavoriteEmoji (limit) {\n    assertNumber(limit);\n    await this.ready();\n    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji)\n  }\n\n  set customEmoji (customEmojis) {\n    this._custom = customEmojiIndex(customEmojis);\n  }\n\n  get customEmoji () {\n    return this._custom.all\n  }\n\n  async _shutdown () {\n    await this.ready(); // reopen if we've already been closed/deleted\n    try {\n      await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n    } catch (err) { /* ignore network errors (offline-first) */ }\n  }\n\n  // clear references to IDB, e.g. during a close event\n  _clear () {\n    // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n    // The memory leak tests prove this is unnecessary. It's because:\n    // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n    // 2) we clear the manual close listeners in databaseLifecycle.js.\n    this._db = this._ready = this._lazyUpdate = undefined;\n  }\n\n  async close () {\n    await this._shutdown();\n    await closeDatabase(this._dbName);\n  }\n\n  async delete () {\n    await this._shutdown();\n    await deleteDatabase(this._dbName);\n  }\n}\n\nexport { Database as default };\n"],"names":["assertNonEmptyString","str","Error","assertNumber","number","STORE_EMOJI","STORE_KEYVALUE","STORE_FAVORITES","INDEX_TOKENS","INDEX_COUNT","INDEX_GROUP_AND_ORDER","KEY_ETAG","KEY_URL","KEY_PREFERRED_SKINTONE","MODE_READONLY","MODE_READWRITE","INDEX_SKIN_UNICODE","uniqEmoji","emojis","arr","func","set","Set","res","item","key","has","add","push","uniqBy","_","unicode","openReqs","databaseCache","onCloseListeners","handleOpenOrDeleteReq","resolve","reject","req","onerror","error","onblocked","onsuccess","result","async","createDatabase","dbName","db","Promise","indexedDB","open","onupgradeneeded","e","oldVersion","createObjectStore","name","keyPath","indexes","store","indexName","multiEntry","Object","entries","createIndex","undefined","initialMigration","onclose","closeDatabase","dbPromise","storeName","readOnlyOrReadWrite","cb","txn","transaction","durability","objectStore","map","oncomplete","close","listeners","listener","irregularEmoticons","extractTokens","split","word","match","toLowerCase","replace","filter","Boolean","normalizeTokens","length","callStore","method","target","getIDB","getAllIDB","commit","findCommonMembers","arrays","uniqByFunc","shortestArray","array","minItem","i","minBy","results","some","findIndex","loadData","emojiData","url","eTag","transformedData","annotation","emoticon","group","order","shortcodes","skins","tags","emoji","version","tokens","flat","sort","skinTones","skinUnicodes","skinVersions","tone","transformEmojiData","emojiStore","metaStore","oldETag","oldUrl","todo","checkFetched","clear","data","put","onFetched","getEmojiBySearchQuery","query","intermediateResults","onDone","a","b","token","range","IDBKeyRange","bound","only","index","getEmojiByShortcode","shortcode","predicate","includes","lastKey","processNextBatch","getAll","lowerBound","doFullDatabaseScanForSingleResult","lowerShortcodes","get","requiredKeys$1","customEmojiIndex","customEmojis","isArray","Array","firstItemIsFaulty","assertCustomEmojis","sortByName","all","searchTrie","itemToTokens","Map","currentMap","char","charAt","nextMap","valuesAtCoda","exact","queue","entriesSortedByKey","shift","value","trie","searchByExactMatch","searchByPrefix","shortcodeToEmoji","nameToEmoji","customEmoji","search","byShortcode","byName","cleanEmoji","len","warnETag","console","warn","requiredKeys","assertStatus","response","dataSource","Math","floor","status","getETagAndData","fetch","headers","json","assertEmojiData","jsonChecksum","object","inBuffer","binary","buf","ArrayBuffer","Uint8Array","charCodeAt","binaryStringToArrayBuffer","JSON","stringify","outBinString","buffer","bytes","byteLength","String","fromCharCode","arrayBufferToBinaryString","crypto","subtle","digest","btoa","checkForUpdates","getETag","eTagAndData","hasData","Database","constructor","locale","this","_dbName","_db","_lazyUpdate","_custom","_clear","bind","_ready","_init","addOnCloseListener","empty","isEmpty","loadDataForFirstTime","checkReady","ready","getEmojiByGroup","custom","unicodeOrName","getEmojiByUnicode","skinTone","limit","favoritesStore","openCursor","cursor","addResult","continue","primaryKey","getTopFavoriteEmoji","err","_shutdown","deleteDatabase"],"sourceRoot":""}