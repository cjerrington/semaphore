{"version":3,"file":"7323.5eb905bd2677529397af.7323.js","mappings":"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","sources":["webpack://semaphore/./src/routes/_actions/addStatusOrNotification.js","webpack://semaphore/./src/routes/_actions/emoji.js","webpack://semaphore/./src/routes/_api/emoji.js","webpack://semaphore/./src/routes/_actions/media.js","webpack://semaphore/./src/routes/_api/media.js","webpack://semaphore/./src/routes/_utils/asyncModules/importDatabase.js","webpack://semaphore/./src/routes/_database/asyncDatabase.js","webpack://semaphore/./src/routes/_utils/arrays.js","webpack://semaphore/./src/routes/_utils/createSearchIndexFromStatusOrNotification.js","webpack://semaphore/./src/routes/_utils/computeFilterContextsForStatusOrNotification.js","webpack://semaphore/./src/routes/_utils/sync.js","webpack://semaphore/./src/routes/_utils/timelineItemToSummary.js"],"sourcesContent":["import { mark, stop } from '../_utils/marks.js'\nimport { store } from '../_store/store.js'\nimport { uniqBy, isEqual } from '../_thirdparty/lodash/objects.js'\nimport { database } from '../_database/database.js'\nimport { concat } from '../_utils/arrays.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\nimport { timelineItemToSummary } from '../_utils/timelineItemToSummary.js'\n\nfunction getExistingItemIdsSet (instanceName, timelineName) {\n  const timelineItemSummaries = store.getForTimeline(instanceName, timelineName, 'timelineItemSummaries') || []\n  return new Set(timelineItemSummaries.map(_ => _.id))\n}\n\nfunction removeDuplicates (instanceName, timelineName, updates) {\n  // remove duplicates, including duplicates due to reblogs\n  const existingItemIds = getExistingItemIdsSet(instanceName, timelineName)\n  return updates.filter(update => !existingItemIds.has(update.id))\n}\n\nasync function insertUpdatesIntoTimeline (instanceName, timelineName, updates) {\n  updates = removeDuplicates(instanceName, timelineName, updates)\n\n  if (!updates.length) {\n    return\n  }\n\n  await database.insertTimelineItems(instanceName, timelineName, updates)\n\n  const itemSummariesToAdd = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesToAdd') || []\n  console.log('itemSummariesToAdd', JSON.parse(JSON.stringify(itemSummariesToAdd)))\n  console.log('updates.map(timelineItemToSummary)', JSON.parse(JSON.stringify(updates.map(timelineItemToSummary))))\n  console.log('concat(itemSummariesToAdd, updates.map(timelineItemToSummary))',\n    JSON.parse(JSON.stringify(concat(itemSummariesToAdd, updates.map(item => timelineItemToSummary(item, instanceName))))))\n  const newItemSummariesToAdd = uniqBy(\n    concat(itemSummariesToAdd, updates.map(item => timelineItemToSummary(item, instanceName))),\n    _ => _.id\n  )\n  if (!isEqual(itemSummariesToAdd, newItemSummariesToAdd)) {\n    console.log('adding ', (newItemSummariesToAdd.length - itemSummariesToAdd.length),\n      'items to timelineItemSummariesToAdd for timeline', timelineName)\n    store.setForTimeline(instanceName, timelineName, { timelineItemSummariesToAdd: newItemSummariesToAdd })\n  }\n}\n\nfunction isValidStatusForThread (thread, timelineName, itemSummariesToAdd) {\n  const itemSummariesToAddIdSet = new Set(itemSummariesToAdd.map(_ => _.id))\n  const threadIdSet = new Set(thread.map(_ => _.id))\n  const focusedStatusId = timelineName.split('/')[1] // e.g. \"status/123456\"\n  const focusedStatusIdx = thread.findIndex(_ => _.id === focusedStatusId)\n  return status => {\n    const repliedToStatusIdx = thread.findIndex(_ => _.id === status.in_reply_to_id)\n    return (\n      // A reply to an ancestor status is not valid for this thread, but for the focused status\n      // itself or any of its descendents, it is valid.\n      repliedToStatusIdx >= focusedStatusIdx &&\n      // Not a duplicate\n      !threadIdSet.has(status.id) &&\n      // Not already about to be added\n      !itemSummariesToAddIdSet.has(status.id)\n    )\n  }\n}\n\nasync function insertUpdatesIntoThreads (instanceName, updates) {\n  if (!updates.length) {\n    return\n  }\n\n  const threads = store.getThreads(instanceName)\n  const timelineNames = Object.keys(threads)\n  for (const timelineName of timelineNames) {\n    const thread = threads[timelineName]\n\n    const itemSummariesToAdd = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesToAdd') || []\n    const validUpdates = updates.filter(isValidStatusForThread(thread, timelineName, itemSummariesToAdd))\n    if (!validUpdates.length) {\n      continue\n    }\n    const newItemSummariesToAdd = uniqBy(\n      concat(itemSummariesToAdd, validUpdates.map(item => timelineItemToSummary(item, instanceName))),\n      _ => _.id\n    )\n    if (!isEqual(itemSummariesToAdd, newItemSummariesToAdd)) {\n      console.log('adding ', (newItemSummariesToAdd.length - itemSummariesToAdd.length),\n        'items to timelineItemSummariesToAdd for thread', timelineName)\n      store.setForTimeline(instanceName, timelineName, { timelineItemSummariesToAdd: newItemSummariesToAdd })\n    }\n  }\n}\n\nasync function processFreshUpdates (instanceName, timelineName) {\n  mark('processFreshUpdates')\n  const freshUpdates = store.getForTimeline(instanceName, timelineName, 'freshUpdates')\n  if (freshUpdates && freshUpdates.length) {\n    const updates = freshUpdates.slice()\n    store.setForTimeline(instanceName, timelineName, { freshUpdates: [] })\n\n    await Promise.all([\n      insertUpdatesIntoTimeline(instanceName, timelineName, updates),\n      insertUpdatesIntoThreads(instanceName, updates.filter(status => status.in_reply_to_id))\n    ])\n  }\n  stop('processFreshUpdates')\n}\n\nfunction lazilyProcessFreshUpdates (instanceName, timelineName) {\n  scheduleIdleTask(() => {\n    /* no await */ processFreshUpdates(instanceName, timelineName)\n  })\n}\n\nexport function addStatusOrNotification (instanceName, timelineName, newStatusOrNotification) {\n  addStatusesOrNotifications(instanceName, timelineName, [newStatusOrNotification])\n}\n\nexport function addStatusesOrNotifications (instanceName, timelineName, newStatusesOrNotifications) {\n  console.log('addStatusesOrNotifications', Date.now())\n  let freshUpdates = store.getForTimeline(instanceName, timelineName, 'freshUpdates') || []\n  freshUpdates = concat(freshUpdates, newStatusesOrNotifications)\n  freshUpdates = uniqBy(freshUpdates, _ => _.id)\n  store.setForTimeline(instanceName, timelineName, { freshUpdates })\n  lazilyProcessFreshUpdates(instanceName, timelineName)\n}\n","import {\n  cacheFirstUpdateAfter,\n  cacheFirstUpdateOnlyIfNotInCache\n} from '../_utils/sync.js'\nimport { database } from '../_database/database.js'\nimport { getCustomEmoji } from '../_api/emoji.js'\nimport { store } from '../_store/store.js'\nimport { isEqual } from '../_thirdparty/lodash/objects.js'\n\nasync function syncEmojiForInstance (instanceName, syncMethod) {\n  await syncMethod(\n    () => {\n      const { loggedInInstances } = store.get()\n      const accessToken = loggedInInstances[instanceName].access_token\n      return getCustomEmoji(instanceName, accessToken)\n    },\n    () => database.getCustomEmoji(instanceName),\n    emoji => database.setCustomEmoji(instanceName, emoji),\n    emoji => {\n      const { customEmoji } = store.get()\n      if (!isEqual(customEmoji[instanceName], emoji)) { // avoid triggering updates if nothing's changed\n        customEmoji[instanceName] = emoji\n        store.set({ customEmoji })\n      }\n    }\n  )\n}\n\nexport async function updateCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateAfter)\n}\n\nexport async function setupCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateOnlyIfNotInCache)\n}\n\nexport function insertEmoji (realm, emoji) {\n  const emojiText = emoji.unicode || `:${emoji.name}:`\n  const { composeSelectionStart } = store.get()\n  const idx = composeSelectionStart || 0\n  const oldText = store.getComposeData(realm, 'text') || ''\n  const pre = oldText.substring(0, idx)\n  const post = oldText.substring(idx)\n  const newText = `${pre}${emojiText} ${post}`\n  store.setComposeData(realm, { text: newText })\n}\n","import { auth, basename } from './utils.js'\nimport { DEFAULT_TIMEOUT, get } from '../_utils/ajax.js'\n\nexport function getCustomEmoji (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/custom_emojis`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n","import { store } from '../_store/store.js'\nimport { uploadMedia } from '../_api/media.js'\nimport { toast } from '../_components/toast/toast.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\nimport { formatIntl } from '../_utils/formatIntl.js'\nimport { database } from '../_database/database.js'\n\nexport async function doMediaUpload (realm, file) {\n  const { currentInstance, accessToken } = store.get()\n  store.set({ uploadingMedia: true })\n  try {\n    const response = await uploadMedia(currentInstance, accessToken, file)\n    const composeMedia = store.getComposeData(realm, 'media') || []\n    if (composeMedia.length === 4) {\n      throw new Error('Only 4 media max are allowed')\n    }\n    await database.setCachedMediaFile(response.id, file)\n    composeMedia.push({\n      data: response,\n      file: { name: file.name },\n      description: ''\n    })\n    store.setComposeData(realm, {\n      media: composeMedia\n    })\n    scheduleIdleTask(() => store.save())\n  } catch (e) {\n    console.error(e)\n    /* no await */ toast.say(formatIntl([\"Failed to upload media: \",[\"error\"]], { error: (e.message || '') }))\n  } finally {\n    store.set({ uploadingMedia: false })\n  }\n}\n\nexport function deleteMedia (realm, i) {\n  const composeMedia = store.getComposeData(realm, 'media')\n  composeMedia.splice(i, 1)\n\n  store.setComposeData(realm, {\n    media: composeMedia\n  })\n  if (!composeMedia.length) {\n    const contentWarningShown = store.getComposeData(realm, 'contentWarningShown')\n    const contentWarning = store.getComposeData(realm, 'contentWarning')\n    store.setComposeData(realm, {\n      sensitive: contentWarningShown && contentWarning // reset sensitive if the last media is deleted\n    })\n  }\n  scheduleIdleTask(() => store.save())\n}\n","import { auth, basename } from './utils.js'\nimport { post, put, MEDIA_WRITE_TIMEOUT, WRITE_TIMEOUT } from '../_utils/ajax.js'\n\nasync function doUploadMedia (version, instanceName, accessToken, file, description) {\n  const formData = new FormData()\n  formData.append('file', file)\n  if (description) {\n    formData.append('description', description)\n  }\n  const url = `${basename(instanceName)}/api/${version}/media`\n  return post(url, formData, auth(accessToken), { timeout: MEDIA_WRITE_TIMEOUT })\n}\n\nasync function doPutMediaMetadata (version, instanceName, accessToken, mediaId, description, focus) {\n  const url = `${basename(instanceName)}/api/${version}/media/${mediaId}`\n  return put(url, { description, focus: (focus && focus.join(',')) }, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n\nexport async function uploadMedia (instanceName, accessToken, file, description) {\n  try {\n    return (await doUploadMedia('v2', instanceName, accessToken, file, description))\n  } catch (err) {\n    if (err && err.status === 404) { // fall back to old v1 API\n      return doUploadMedia('v1', instanceName, accessToken, file, description)\n    } else {\n      throw err\n    }\n  }\n}\n\nexport async function putMediaMetadata (instanceName, accessToken, mediaId, description, focus) {\n  try {\n    return (await doPutMediaMetadata('v2', instanceName, accessToken, mediaId, description, focus))\n  } catch (err) {\n    if (err && err.status === 404) { // fall back to old v1 API\n      return doPutMediaMetadata('v1', instanceName, accessToken, mediaId, description, focus)\n    } else {\n      throw err\n    }\n  }\n}\n","export const importDatabase = () => import(\n  '../../_database/databaseApis.js'\n)\n","// All database functions are asynchronous, so we can just proxy here and\n// put an async import of the database, to avoid including it in the main bundle\n// (which doesn't need to run when the user isn't logged in).\n\nimport { importDatabase } from '../_utils/asyncModules/importDatabase.js'\n\nconst handler = {\n  get: function (obj, prop) {\n    return async function (...args) {\n      if (!obj[prop]) {\n        const database = await importDatabase()\n        obj[prop] = database[prop]\n      }\n      return obj[prop].apply(null, args)\n    }\n  }\n}\n\nexport const asyncDatabase = new Proxy({}, handler)\n","// Merge two arrays, using the given comparator\nexport function mergeArrays (leftArray, rightArray, comparator) {\n  let leftIndex = 0\n  let rightIndex = 0\n  const merged = []\n  while (leftIndex < leftArray.length || rightIndex < rightArray.length) {\n    if (leftIndex === leftArray.length) {\n      merged.push(rightArray[rightIndex])\n      rightIndex++\n      continue\n    }\n    if (rightIndex === rightArray.length) {\n      merged.push(leftArray[leftIndex])\n      leftIndex++\n      continue\n    }\n    const left = leftArray[leftIndex]\n    const right = rightArray[rightIndex]\n    const comparison = comparator(right, left)\n    if (comparison === 0) {\n      merged.push(left)\n      rightIndex++\n      leftIndex++\n    } else if (comparison > 0) {\n      merged.push(right)\n      rightIndex++\n    } else {\n      merged.push(left)\n      leftIndex++\n    }\n  }\n  return merged\n}\n\nexport function concat () {\n  let res = []\n  for (let i = 0, len = arguments.length; i < len; i++) {\n    const arg = arguments[i]\n    if (Array.isArray(arg)) {\n      res = res.concat(arguments[i])\n    } else {\n      res.push(arguments[i])\n    }\n  }\n  return res\n}\n","let domParser\n\n// copy-pasta'd from\n// https://github.com/tootsuite/mastodon/blob/2ff01f7/app/javascript/mastodon/actions/importer/normalizer.js#L58-L75\nexport const createSearchIndexFromStatusOrNotification = statusOrNotification => {\n  const status = statusOrNotification.status || statusOrNotification // status on a notification\n  const originalStatus = status.reblog || status\n  domParser = domParser || new DOMParser()\n  const spoilerText = originalStatus.spoiler_text || ''\n  const searchContent = ([spoilerText, originalStatus.content]\n    .concat(\n      (originalStatus.poll && originalStatus.poll.options)\n        ? originalStatus.poll.options.map(option => option.title)\n        : []\n    ))\n    .join('\\n\\n').replace(/<br\\s*\\/?>/g, '\\n').replace(/<\\/p><p>/g, '\\n\\n')\n  return domParser.parseFromString(searchContent, 'text/html').documentElement.textContent\n}\n","import { createSearchIndexFromStatusOrNotification } from './createSearchIndexFromStatusOrNotification.js'\n\nexport function computeFilterContextsForStatusOrNotification (statusOrNotification, contextsToRegex) {\n  if (!contextsToRegex || !Object.keys(contextsToRegex).length) {\n    // avoid computing the search index, just bail out\n    return undefined\n  }\n  // the searchIndex is really just a string of text\n  const searchIndex = createSearchIndexFromStatusOrNotification(statusOrNotification)\n  const res = Object.entries(contextsToRegex)\n    .filter(([context, regex]) => regex.test(searchIndex))\n    .map(([context]) => context)\n\n  // return undefined instead of a new array to reduce memory usage of TimelineSummary\n  return res.length ? res : undefined\n}\n","// Hit both the cache and the network, setting state for the cached version first,\n// then the network version (as it's assumed to be fresher). Also update the db afterwards.\nexport async function cacheFirstUpdateAfter (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  const networkPromise = networkFetcher() // kick off network request immediately\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  } finally {\n    if (dbResponse) {\n      stateSetter(dbResponse)\n    }\n    const fetchAndUpdatePromise = networkPromise.then(networkResponse => {\n      /* no await */ dbUpdater(networkResponse)\n      stateSetter(networkResponse)\n    })\n    if (!dbResponse) { // no cached result available, await the network\n      await fetchAndUpdatePromise\n    }\n  }\n}\n\n// Try the cache first. If we get a hit, set the state and do nothing. If we don't get a cache hit,\n// then go to the network, update the cache, and set the state.\nexport async function cacheFirstUpdateOnlyIfNotInCache (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  }\n  if (dbResponse) {\n    stateSetter(dbResponse)\n  } else {\n    const networkResponse = await networkFetcher()\n    /* no await */ dbUpdater(networkResponse)\n    stateSetter(networkResponse)\n  }\n}\n","import { computeFilterContextsForStatusOrNotification } from './computeFilterContextsForStatusOrNotification.js'\nimport { store } from '../_store/store.js'\n\nclass TimelineSummary {\n  constructor (item, instanceName) {\n    this.id = item.id\n    this.accountId = item.account.id\n    this.replyId = (item.in_reply_to_id) || undefined\n    this.reblogId = (item.reblog && item.reblog.id) || undefined\n    this.type = item.type || undefined\n\n    // This is admittedly a weird place to do the filtering logic. But there are a few reasons to do it here:\n    // 1. Avoid computing html-to-text (expensive) for users who don't have any filters (probably most users)\n    // 2. Avoiding keeping the entire html-to-text in memory at all times for all summaries\n    // 3. Filters probably change infrequently. When they do, we can just update the summaries\n    const { unexpiredInstanceFilterRegexes } = store.get()\n    const contextsToRegex = unexpiredInstanceFilterRegexes[instanceName]\n    this.filterContexts = computeFilterContextsForStatusOrNotification(item, contextsToRegex)\n  }\n}\n\nexport function timelineItemToSummary (item, instanceName) {\n  return new TimelineSummary(item, instanceName)\n}\n"],"names":["removeDuplicates","instanceName","timelineName","updates","existingItemIds","timelineItemSummaries","Set","map","_","id","getExistingItemIdsSet","filter","update","has","async","insertUpdatesIntoTimeline","length","itemSummariesToAdd","JSON","parse","stringify","item","newItemSummariesToAdd","timelineItemSummariesToAdd","isValidStatusForThread","thread","itemSummariesToAddIdSet","threadIdSet","focusedStatusId","split","focusedStatusIdx","findIndex","status","in_reply_to_id","insertUpdatesIntoThreads","threads","timelineNames","Object","keys","validUpdates","lazilyProcessFreshUpdates","freshUpdates","slice","Promise","all","s","processFreshUpdates","addStatusOrNotification","newStatusOrNotification","addStatusesOrNotifications","newStatusesOrNotifications","Date","now","syncEmojiForInstance","syncMethod","loggedInInstances","store","accessToken","access_token","url","timeout","getCustomEmoji","database","emoji","customEmoji","updateCustomEmojiForInstance","setupCustomEmojiForInstance","insertEmoji","realm","emojiText","unicode","name","composeSelectionStart","idx","oldText","newText","substring","text","doMediaUpload","file","currentInstance","uploadingMedia","response","composeMedia","Error","push","data","description","media","e","console","error","message","deleteMedia","i","splice","contentWarningShown","contentWarning","sensitive","doUploadMedia","version","formData","FormData","append","doPutMediaMetadata","mediaId","focus","join","uploadMedia","err","putMediaMetadata","asyncDatabase","Proxy","get","obj","prop","args","apply","mergeArrays","leftArray","rightArray","comparator","leftIndex","rightIndex","merged","left","right","comparison","concat","res","len","arguments","arg","Array","isArray","domParser","computeFilterContextsForStatusOrNotification","statusOrNotification","contextsToRegex","searchIndex","originalStatus","reblog","DOMParser","searchContent","spoiler_text","content","poll","options","option","title","replace","parseFromString","documentElement","textContent","createSearchIndexFromStatusOrNotification","entries","context","regex","test","undefined","cacheFirstUpdateAfter","networkFetcher","dbFetcher","dbUpdater","stateSetter","networkPromise","dbResponse","fetchAndUpdatePromise","then","networkResponse","cacheFirstUpdateOnlyIfNotInCache","TimelineSummary","constructor","this","accountId","account","replyId","reblogId","type","unexpiredInstanceFilterRegexes","filterContexts","timelineItemToSummary"],"sourceRoot":""}