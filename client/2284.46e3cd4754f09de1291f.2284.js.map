{"version":3,"file":"2284.46e3cd4754f09de1291f.2284.js","mappings":"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","sources":["webpack://semaphore/./node_modules/li/lib/index.js","webpack://semaphore/./src/routes/_components/DynamicHeading.html","webpack://semaphore/./src/routes/_utils/sortItemSummariesForThread.js","webpack://semaphore/./src/routes/_utils/maps.js","webpack://semaphore/./src/routes/_actions/timeline.js","webpack://semaphore/./src/routes/_components/timeline/LoadingFooter.html","webpack://semaphore/./src/routes/_components/timeline/MoreHeader.html","webpack://semaphore/./src/routes/_components/timeline/MoreHeaderVirtualWrapper.html","webpack://semaphore/./src/routes/_utils/scrollIntoView.js","webpack://semaphore/./src/routes/_components/shortcut/ScrollListShortcuts.html","webpack://semaphore/./src/routes/_actions/createMakeProps.js","webpack://semaphore/./src/routes/_components/timeline/Timeline.html","webpack://semaphore/./src/routes/_actions/showMoreAndScrollToTop.js","webpack://semaphore/./src/routes/_utils/asyncModules/importList.js","webpack://semaphore/./src/routes/_utils/asyncModules/importVirtualList.js","webpack://semaphore/./src/routes/_utils/asyncModules/importNotificationVirtualListItem.js","webpack://semaphore/./src/routes/_utils/asyncModules/importStatusVirtualListItem.js","webpack://semaphore/./src/routes/_api/timelines.js","webpack://semaphore/./src/routes/_static/timelines.js","webpack://semaphore/./src/routes/_utils/statusIdSorting.js"],"sourcesContent":["(function (name, definition, context) {\n\n  //try CommonJS, then AMD (require.js), then use global.\n\n  if (typeof module != 'undefined' && module.exports) module.exports = definition();\n  else if (typeof context['define'] == 'function' && context['define']['amd']) define(definition);\n  else context[name] = definition();\n\n})('li', function () {\n  // compile regular expressions ahead of time for efficiency\n  var relsRegExp = /^;\\s*([^\"=]+)=(?:\"([^\"]+)\"|([^\";,]+)(?:[;,]|$))/;\n  var sourceRegExp = /^<([^>]*)>/;\n  var delimiterRegExp = /^\\s*,\\s*/;\n\n  return {\n    parse: function (linksHeader, options) {\n      var match;\n      var source;\n      var rels;\n      var extended = options && options.extended || false;\n      var links = [];\n\n      while (linksHeader) {\n        linksHeader = linksHeader.trim();\n\n        // Parse `<link>`\n        source = sourceRegExp.exec(linksHeader);\n        if (!source) break;\n\n        var current = {\n          link: source[1]\n        };\n\n        // Move cursor\n        linksHeader = linksHeader.slice(source[0].length);\n\n        // Parse `; attr=relation` and `; attr=\"relation\"`\n\n        var nextDelimiter = linksHeader.match(delimiterRegExp);\n        while(linksHeader && (!nextDelimiter || nextDelimiter.index > 0)) {\n          match = relsRegExp.exec(linksHeader);\n          if (!match) break;\n\n          // Move cursor\n          linksHeader = linksHeader.slice(match[0].length);\n          nextDelimiter = linksHeader.match(delimiterRegExp);\n\n\n          if (match[1] === 'rel' || match[1] === 'rev') {\n            // Add either quoted rel or unquoted rel\n            rels = (match[2] || match[3]).split(/\\s+/);\n            current[match[1]] = rels;\n          } else {\n            current[match[1]] = match[2] || match[3];\n          }\n        }\n\n        links.push(current);\n        // Move cursor\n        linksHeader = linksHeader.replace(delimiterRegExp, '');\n      }\n\n      if (!extended) {\n        return links.reduce(function(result, currentLink) {\n          if (currentLink.rel) {\n            currentLink.rel.forEach(function(rel) {\n              result[rel] = currentLink.link;\n            });\n          }\n          return result;\n        }, {});\n      }\n\n      return links;\n    },\n    stringify: function (params) {\n      var grouped = Object.keys(params).reduce(function(grouped, key) {\n        grouped[params[key]] = grouped[params[key]] || [];\n        grouped[params[key]].push(key);\n        return grouped;\n      }, {});\n\n      var entries = Object.keys(grouped).reduce(function(result, link) {\n        return result.concat('<' + link + '>; rel=\"' + grouped[link].join(' ') + '\"');\n      }, []);\n\n      return entries.join(', ');\n    }\n  };\n\n}, this);\n","{#if level === 2}\n  <h2 class={className || ''}><slot></slot></h2>\n{:else}\n  <h1 class={className || ''}><slot></slot></h1>\n{/if}\n","// This is designed to exactly mimic Mastodon's ordering for threads. As described by Gargron:\n// \"statuses are ordered in the postgresql query and then any of OP's self-replies bubble to the top\"\n// Source: https://github.com/tootsuite/mastodon/blob/ef15246/app/models/concerns/status_threading_concern.rb\nimport { concat } from './arrays.js'\nimport { compareTimelineItemSummaries } from './statusIdSorting.js'\nimport { mapBy, multimapBy } from './maps.js'\n\nexport function sortItemSummariesForThread (summaries, statusId) {\n  const ancestors = []\n  const descendants = []\n  const summariesById = mapBy(summaries, _ => _.id)\n  const summariesByReplyId = multimapBy(summaries, _ => _.replyId)\n\n  const status = summariesById.get(statusId)\n  if (!status) {\n    // bail out, for some reason we can't find the status (should never happen)\n    return summaries\n  }\n\n  // find ancestors\n  let currentStatus = status\n  do {\n    currentStatus = summariesById.get(currentStatus.replyId)\n    if (currentStatus) {\n      ancestors.unshift(currentStatus)\n    }\n  } while (currentStatus)\n\n  // find descendants\n  // This mirrors the depth-first ordering used in the Postgres query in the Mastodon implementation\n  const stack = [status]\n  while (stack.length) {\n    const current = stack.shift()\n    const newChildren = (summariesByReplyId.get(current.id) || []).sort(compareTimelineItemSummaries)\n    Array.prototype.unshift.apply(stack, newChildren)\n    if (current.id !== status.id) { // the status is not a descendant of itself\n      descendants.push(current)\n    }\n  }\n\n  // Normally descendants are sorted in depth-first order, via normal ID sorting\n  // but replies that come from the account they're actually replying to get promoted\n  // This only counts if it's an unbroken self-reply, e.g. in the case of\n  //     A -> A -> A -> B -> A -> A\n  // B has broken the chain, so only the first three As are considered unbroken self-replies\n  const isUnbrokenSelfReply = (descendant) => {\n    let current = descendant\n    while (true) {\n      if (current.accountId !== status.accountId) {\n        return false\n      }\n      const parent = summariesById.get(current.replyId)\n      if (!parent) {\n        break\n      }\n      current = parent\n    }\n    return current.id === statusId\n  }\n\n  const promotedDescendants = []\n  const otherDescendants = []\n  for (const descendant of descendants) {\n    (isUnbrokenSelfReply(descendant) ? promotedDescendants : otherDescendants).push(descendant)\n  }\n\n  return concat(\n    ancestors,\n    [status],\n    promotedDescendants,\n    otherDescendants\n  )\n}\n","// utilities for working with Maps\n\nexport function mapBy (items, func) {\n  const map = new Map()\n  for (const item of items) {\n    map.set(func(item), item)\n  }\n  return map\n}\n\nexport function multimapBy (items, func) {\n  const map = new Map()\n  for (const item of items) {\n    const key = func(item)\n    if (map.has(key)) {\n      map.get(key).push(item)\n    } else {\n      map.set(key, [item])\n    }\n  }\n  return map\n}\n","import { store } from '../_store/store.js'\nimport { getTimeline } from '../_api/timelines.js'\nimport { toast } from '../_components/toast/toast.js'\nimport { mark, stop } from '../_utils/marks.js'\nimport { concat, mergeArrays } from '../_utils/arrays.js'\nimport { compareTimelineItemSummaries } from '../_utils/statusIdSorting.js'\nimport { uniqBy, isEqual } from '../_thirdparty/lodash/objects.js'\nimport { database } from '../_database/database.js'\nimport { getStatus, getStatusContext } from '../_api/statuses.js'\nimport { emit } from '../_utils/eventBus.js'\nimport { TIMELINE_BATCH_SIZE } from '../_static/timelines.js'\nimport { timelineItemToSummary } from '../_utils/timelineItemToSummary.js'\nimport { addStatusesOrNotifications } from './addStatusOrNotification.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\nimport { sortItemSummariesForThread } from '../_utils/sortItemSummariesForThread.js'\nimport li from 'li'\n\nconst byId = _ => _.id\n\nasync function storeFreshTimelineItemsInDatabase (instanceName, timelineName, items) {\n  await database.insertTimelineItems(instanceName, timelineName, items)\n  if (timelineName.startsWith('status/')) {\n    // For status threads, we want to be sure to update the favorite/reblog counts even if\n    // this is a stale \"view\" of the status. See 119-status-counts-update.js for\n    // an example of why we need this.\n    items.forEach(item => {\n      emit('statusUpdated', item)\n    })\n  }\n}\n\nasync function updateStatus (instanceName, accessToken, statusId) {\n  const status = await getStatus(instanceName, accessToken, statusId)\n  await database.insertStatus(instanceName, status)\n  emit('statusUpdated', status)\n  return status\n}\n\nasync function updateStatusAndThread (instanceName, accessToken, timelineName, statusId) {\n  const [status, context] = await Promise.all([\n    updateStatus(instanceName, accessToken, statusId),\n    getStatusContext(instanceName, accessToken, statusId)\n  ])\n  await database.insertTimelineItems(\n    instanceName,\n    timelineName,\n    concat(context.ancestors, status, context.descendants)\n  )\n  addStatusesOrNotifications(instanceName, timelineName, concat(context.ancestors, context.descendants))\n}\n\nasync function fetchFreshThreadFromNetwork (instanceName, accessToken, statusId) {\n  const [status, context] = await Promise.all([\n    getStatus(instanceName, accessToken, statusId),\n    getStatusContext(instanceName, accessToken, statusId)\n  ])\n  return concat(context.ancestors, status, context.descendants)\n}\n\nasync function fetchThreadFromNetwork (instanceName, accessToken, timelineName) {\n  const statusId = timelineName.split('/').slice(-1)[0]\n\n  // For threads, we do several optimizations to make it a bit faster to load.\n  // The vast majority of statuses have no replies and aren't in reply to anything,\n  // so we want that to be as fast as possible.\n  const status = await database.getStatus(instanceName, statusId)\n  if (!status) {\n    // If for whatever reason the status is not cached, fetch everything from the network\n    // and wait for the result. This happens in very unlikely cases (e.g. loading /statuses/<id>\n    // where <id> is not cached locally) but is worth covering.\n    return fetchFreshThreadFromNetwork(instanceName, accessToken, statusId)\n  }\n\n  if (!status.in_reply_to_id) {\n    // status is not a reply to another status (fast path)\n    // Update the status and thread asynchronously, but return just the status for now\n    // Any replies to the status will load asynchronously\n    /* no await */ updateStatusAndThread(instanceName, accessToken, timelineName, statusId)\n    return [status]\n  }\n  // status is a reply to some other status, meaning we don't want some\n  // jerky behavior where it suddenly scrolls into place. Update the status asynchronously\n  // but grab the thread now\n  scheduleIdleTask(() => updateStatus(instanceName, accessToken, statusId))\n  const context = await getStatusContext(instanceName, accessToken, statusId)\n  return concat(context.ancestors, status, context.descendants)\n}\n\nasync function fetchTimelineItemsFromNetwork (instanceName, accessToken, timelineName, lastTimelineItemId) {\n  if (timelineName.startsWith('status/')) { // special case - this is a list of descendents and ancestors\n    return fetchThreadFromNetwork(instanceName, accessToken, timelineName)\n  } else { // normal timeline\n    const { items } = await getTimeline(instanceName, accessToken, timelineName, lastTimelineItemId, null, TIMELINE_BATCH_SIZE)\n    return items\n  }\n}\nasync function addPagedTimelineItems (instanceName, timelineName, items) {\n  console.log('addPagedTimelineItems, length:', items.length)\n  mark('addPagedTimelineItemSummaries')\n  const newSummaries = items.map(item => timelineItemToSummary(item, instanceName))\n  await addPagedTimelineItemSummaries(instanceName, timelineName, newSummaries)\n  stop('addPagedTimelineItemSummaries')\n}\n\nexport async function addPagedTimelineItemSummaries (instanceName, timelineName, newSummaries) {\n  const oldSummaries = store.getForTimeline(instanceName, timelineName, 'timelineItemSummaries')\n\n  const mergedSummaries = uniqBy(concat(oldSummaries || [], newSummaries), byId)\n\n  if (!isEqual(oldSummaries, mergedSummaries)) {\n    store.setForTimeline(instanceName, timelineName, { timelineItemSummaries: mergedSummaries })\n  }\n}\n\nasync function fetchPagedItems (instanceName, accessToken, timelineName) {\n  const { timelineNextPageId } = store.get()\n  console.log('saved timelineNextPageId', timelineNextPageId)\n  const { items, headers } = await getTimeline(instanceName, accessToken, timelineName, timelineNextPageId, null, TIMELINE_BATCH_SIZE)\n  const linkHeader = headers.get('Link')\n  const parsedLinkHeader = li.parse(linkHeader)\n  const nextUrl = parsedLinkHeader && parsedLinkHeader.next\n  const nextId = nextUrl && (new URL(nextUrl)).searchParams.get('max_id')\n  console.log('new timelineNextPageId', nextId)\n  store.setForTimeline(instanceName, timelineName, { timelineNextPageId: nextId })\n  await storeFreshTimelineItemsInDatabase(instanceName, timelineName, items)\n  await addPagedTimelineItems(instanceName, timelineName, items)\n}\n\nasync function fetchTimelineItems (instanceName, accessToken, timelineName, online) {\n  mark('fetchTimelineItems')\n  const { lastTimelineItemId } = store.get()\n  let items\n  let stale = false\n  if (!online) {\n    items = await database.getTimeline(instanceName, timelineName, lastTimelineItemId, TIMELINE_BATCH_SIZE)\n    stale = true\n  } else {\n    try {\n      console.log('fetchTimelineItemsFromNetwork')\n      items = await fetchTimelineItemsFromNetwork(instanceName, accessToken, timelineName, lastTimelineItemId)\n      await storeFreshTimelineItemsInDatabase(instanceName, timelineName, items)\n    } catch (e) {\n      console.error(e)\n      /* no await */ toast.say(\"Internet request failed. Showing offline content.\")\n      items = await database.getTimeline(instanceName, timelineName, lastTimelineItemId, TIMELINE_BATCH_SIZE)\n      stale = true\n    }\n  }\n  stop('fetchTimelineItems')\n  return { items, stale }\n}\n\nasync function addTimelineItems (instanceName, timelineName, items, stale) {\n  console.log('addTimelineItems, length:', items.length)\n  mark('addTimelineItemSummaries')\n  const newSummaries = items.map(item => timelineItemToSummary(item, instanceName))\n  addTimelineItemSummaries(instanceName, timelineName, newSummaries, stale)\n  stop('addTimelineItemSummaries')\n}\n\nexport async function addTimelineItemSummaries (instanceName, timelineName, newSummaries, newStale) {\n  const oldSummaries = store.getForTimeline(instanceName, timelineName, 'timelineItemSummaries')\n  const oldStale = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesAreStale')\n\n  const mergedSummaries = uniqBy(mergeArrays(oldSummaries || [], newSummaries, compareTimelineItemSummaries), byId)\n\n  if (!isEqual(oldSummaries, mergedSummaries)) {\n    store.setForTimeline(instanceName, timelineName, { timelineItemSummaries: mergedSummaries })\n  }\n  if (oldStale !== newStale) {\n    store.setForTimeline(instanceName, timelineName, { timelineItemSummariesAreStale: newStale })\n  }\n}\n\nasync function fetchTimelineItemsAndPossiblyFallBack () {\n  console.log('fetchTimelineItemsAndPossiblyFallBack')\n  mark('fetchTimelineItemsAndPossiblyFallBack')\n  const {\n    currentTimeline,\n    currentInstance,\n    accessToken,\n    online\n  } = store.get()\n\n  if (currentTimeline === 'favorites' || currentTimeline === 'bookmarks') {\n    // Always fetch favorites from the network, we currently don't have a good way of storing\n    // these in IndexedDB because of \"internal ID\" system Mastodon uses to paginate these\n    await fetchPagedItems(currentInstance, accessToken, currentTimeline)\n  } else {\n    const { items, stale } = await fetchTimelineItems(currentInstance, accessToken, currentTimeline, online)\n    await addTimelineItems(currentInstance, currentTimeline, items, stale)\n  }\n  stop('fetchTimelineItemsAndPossiblyFallBack')\n}\n\nexport async function setupTimeline () {\n  console.log('setupTimeline')\n  mark('setupTimeline')\n  // If we don't have any item summaries, or if the current item summaries are stale\n  // (i.e. via offline mode), then we need to re-fetch\n  // Also do this if it's a thread, because threads change pretty frequently and\n  // we don't have a good way to update them.\n  const {\n    timelineItemSummaries,\n    timelineItemSummariesAreStale,\n    currentTimeline\n  } = store.get()\n  console.log({ timelineItemSummaries, timelineItemSummariesAreStale, currentTimeline })\n  if (!timelineItemSummaries ||\n      timelineItemSummariesAreStale ||\n      currentTimeline.startsWith('status/')) {\n    await fetchTimelineItemsAndPossiblyFallBack()\n  }\n  stop('setupTimeline')\n}\n\nexport async function fetchMoreItemsAtBottomOfTimeline (instanceName, timelineName) {\n  console.log('setting runningUpdate: true')\n  store.setForTimeline(instanceName, timelineName, { runningUpdate: true })\n  await fetchTimelineItemsAndPossiblyFallBack()\n  console.log('setting runningUpdate: false')\n  store.setForTimeline(instanceName, timelineName, { runningUpdate: false })\n}\n\nexport async function showMoreItemsForTimeline (instanceName, timelineName) {\n  mark('showMoreItemsForTimeline')\n  let itemSummariesToAdd = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesToAdd') || []\n  itemSummariesToAdd = itemSummariesToAdd.sort(compareTimelineItemSummaries).reverse()\n  addTimelineItemSummaries(instanceName, timelineName, itemSummariesToAdd, false)\n  store.setForTimeline(instanceName, timelineName, {\n    timelineItemSummariesToAdd: [],\n    shouldShowHeader: false,\n    showHeader: false\n  })\n  stop('showMoreItemsForTimeline')\n}\n\nexport function showMoreItemsForCurrentTimeline () {\n  const { currentInstance, currentTimeline } = store.get()\n  return showMoreItemsForTimeline(\n    currentInstance,\n    currentTimeline\n  )\n}\n\nexport async function showMoreItemsForThread (instanceName, timelineName) {\n  mark('showMoreItemsForThread')\n  const itemSummariesToAdd = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesToAdd')\n  const timelineItemSummaries = store.getForTimeline(instanceName, timelineName, 'timelineItemSummaries')\n  const timelineItemIds = new Set(timelineItemSummaries.map(_ => _.id))\n  // TODO: update database and do the thread merge correctly\n  for (const itemSummaryToAdd of itemSummariesToAdd) {\n    if (!timelineItemIds.has(itemSummaryToAdd.id)) {\n      timelineItemSummaries.push(itemSummaryToAdd)\n    }\n  }\n  const statusId = timelineName.split('/').slice(-1)[0]\n  const sortedTimelineItemSummaries = await sortItemSummariesForThread(timelineItemSummaries, statusId)\n  store.setForTimeline(instanceName, timelineName, {\n    timelineItemSummariesToAdd: [],\n    timelineItemSummaries: sortedTimelineItemSummaries\n  })\n  stop('showMoreItemsForThread')\n}\n","<div class=\"loading-footer {shown ? '' : 'hidden'}\">\n  <div class=\"loading-wrapper {showLoading ? 'shown' : ''}\"\n       aria-hidden={!showLoading}\n  >\n    <!-- Sapper's mousemove event listener schedules style recalculations for the loading spinner in\n         Chrome because it's always animating, even when hidden. So disable animations when not visible\n         to avoid this. -->\n    <LoadingSpinner size={48} animate={showLoading} />\n    <span class=\"loading-footer-info\">\n      Loading more…\n    </span>\n  </div>\n  <div class=\"button-wrapper {showLoadButton ? 'shown' : ''}\"\n       aria-hidden={!showLoadButton}\n  >\n    <button type=\"button\"\n            class=\"primary\"\n            on:click=\"onClickLoadMore(event)\">\n      Load more\n    </button>\n  </div>\n</div>\n<style>\n  .loading-footer {\n    padding: 20px 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n  }\n  .loading-wrapper {\n    flex: 1;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    pointer-events: none;\n    transition: opacity 0.2s linear;\n  }\n  .loading-wrapper.shown {\n    opacity: 1;\n    pointer-events: auto;\n  }\n  .loading-footer-info {\n    margin-left: 20px;\n    font-size: 1.3em;\n  }\n  .button-wrapper {\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    top: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    pointer-events: none;\n    transition: none;\n  }\n  .button-wrapper.shown {\n    opacity: 1;\n    pointer-events: auto;\n    transition: opacity 0.2s linear 0.2s;\n  }\n</style>\n<script>\n  import { observe } from 'svelte-extras'\n  import LoadingSpinner from '../LoadingSpinner.html'\n  import { store } from '../../_store/store.js'\n  import { fetchMoreItemsAtBottomOfTimeline } from '../../_actions/timeline.js'\n  import { announceAriaLivePolite } from '../../_utils/announceAriaLivePolite.js'\n\n  const SCREEN_READER_ANNOUNCE_DELAY = 1000 // 1 second\n\n  export default {\n    oncreate () {\n      // If the new statuses are delayed a significant amount of time, announce to screen readers that we're loading\n      let delayedAriaAnnouncementHandle\n\n      this.observe('showLoading', showLoading => {\n        if (showLoading) {\n          delayedAriaAnnouncementHandle = setTimeout(() => {\n            delayedAriaAnnouncementHandle = undefined\n            announceAriaLivePolite(\"Loading more…\")\n          }, SCREEN_READER_ANNOUNCE_DELAY)\n        } else if (delayedAriaAnnouncementHandle) {\n          clearTimeout(delayedAriaAnnouncementHandle)\n        }\n      })\n    },\n    store: () => store,\n    computed: {\n      shown: ({ $timelineInitialized, $runningUpdate, $disableInfiniteScroll }) => (\n        $timelineInitialized && ($disableInfiniteScroll || $runningUpdate)\n      ),\n      showLoading: ({ $runningUpdate }) => $runningUpdate,\n      showLoadButton: ({ $runningUpdate, $disableInfiniteScroll }) => !$runningUpdate && $disableInfiniteScroll\n    },\n    methods: {\n      observe,\n      onClickLoadMore (e) {\n        e.preventDefault()\n        e.stopPropagation()\n        const { currentInstance, currentTimeline } = this.store.get()\n        /* no await */ fetchMoreItemsAtBottomOfTimeline(currentInstance, currentTimeline)\n        // focus the last item in the timeline; it makes the most sense to me since the button disappears\n        try {\n          // TODO: should probably expose this as an API on the virtual list instead of reaching into the DOM\n          const virtualListItems = document.querySelector('.virtual-list').children\n          const lastItem = virtualListItems[virtualListItems.length - 2] // -2 because the footer is last\n          lastItem.querySelector('article').focus()\n        } catch (e) {\n          console.error(e)\n        }\n      }\n    },\n    components: {\n      LoadingSpinner\n    }\n  }\n</script>\n","<div class=\"more-items-header\">\n  <button class=\"primary\" type=\"button\" on:click=\"onClick(event)\">\n    {showMoreLabel}\n  </button>\n</div>\n<style>\n  .more-items-header {\n    display: flex;\n    padding: 5px;\n    align-items: center;\n    justify-content:center;\n  }\n</style>\n<script>\n  import { formatIntl } from '../../_utils/formatIntl.js'\n\n  export default {\n    methods: {\n      onClick (event) {\n        const { onClick } = this.get()\n        if (onClick) {\n          onClick(event)\n        }\n      }\n    },\n    computed: {\n      showMoreLabel: ({ count }) => (\n        formatIntl([\"Show \",[\"count\"],\" more\"], { count })\n      )\n    }\n  }\n</script>\n","<MoreHeader count={virtualProps.count}\n            onClick={virtualProps.onClick}\n/>\n<script>\n  import MoreHeader from './MoreHeader.html'\n  export default {\n    components: {\n      MoreHeader\n    }\n  }\n</script>","import {\n  getScrollContainer,\n  getOffsetHeight\n} from './scrollContainer.js'\nimport { smoothScroll } from './smoothScroll.js'\n\nlet mainNavElement\nfunction getTopOverlay () {\n  if (!mainNavElement) {\n    mainNavElement = document.getElementById('main-nav')\n  }\n  return mainNavElement.clientHeight\n}\n\nexport function isVisible (element) {\n  if (!element) {\n    return false\n  }\n  const rect = element.getBoundingClientRect()\n  const offsetHeight = getOffsetHeight()\n  const topOverlay = getTopOverlay()\n  return rect.top < offsetHeight && rect.bottom >= topOverlay\n}\n\nexport function firstVisibleElementIndex (elements) {\n  const offsetHeight = getOffsetHeight()\n  const topOverlay = getTopOverlay()\n  let first = -1\n  let firstComplete = -1\n  const len = elements.length\n  let i = -1\n  while (++i < len) {\n    const element = elements[i]\n    if (!element) {\n      continue\n    }\n    const rect = element.getBoundingClientRect()\n    if (rect.top < offsetHeight && rect.bottom >= topOverlay) {\n      first = i\n      firstComplete = (rect.top < topOverlay && i < (len - 1)) ? i + 1 : i\n      break\n    }\n  }\n  return { first, firstComplete }\n}\n\nexport function scrollIntoViewIfNeeded (element) {\n  const rect = element.getBoundingClientRect()\n  const topOverlay = getTopOverlay()\n  const offsetHeight = getOffsetHeight()\n  let scrollY = 0\n  if (rect.top < topOverlay) {\n    scrollY = topOverlay\n  } else if (rect.bottom > offsetHeight) {\n    const height = rect.bottom - rect.top\n    if ((offsetHeight - topOverlay) > height) {\n      scrollY = offsetHeight - height\n    } else {\n      // if element height is too great to fit,\n      // prefer showing the top of the element\n      scrollY = topOverlay\n    }\n  } else {\n    return // not needed\n  }\n  const scrollContainer = getScrollContainer()\n  const scrollTop = scrollContainer.scrollTop\n  smoothScroll(scrollContainer, scrollTop + rect.top - scrollY, /* horizontal */ false, /* preferFast */ false)\n}\n","<script>\n  import {\n    isVisible,\n    firstVisibleElementIndex,\n    scrollIntoViewIfNeeded\n} from '../../_utils/scrollIntoView.js'\n  import {\n    addShortcutFallback,\n    removeShortcutFallback,\n    onKeyDownInShortcutScope\n} from '../../_utils/shortcuts.js'\n  import { smoothScroll } from '../../_utils/smoothScroll.js'\n  import { getScrollContainer } from '../../_utils/scrollContainer.js'\n  import { store } from '../../_store/store.js'\n  import { emit } from '../../_utils/eventBus.js'\n\n  const VISIBILITY_CHECK_DELAY_MS = 600\n\n  const keyToElement = key => document.getElementById(key)\n  const elementToKey = element => element.getAttribute('id')\n  const scope = 'global'\n\n  const shouldIgnoreEvent = event => {\n    // For accessibility reasons, do not override the arrowup/arrowdown behavior for radio buttons\n    // (e.g. in a poll). Up/down is supposed to change the radio value, not the current status.\n    const { target, key } = event\n    const isRadio = target &&\n    target.tagName === 'INPUT' &&\n    target.type === 'radio'\n    const isArrow = key === 'ArrowUp' || key === 'ArrowDown'\n    return isRadio && isArrow\n  }\n\n  export default {\n    data: () => ({\n      activeItemChangeTime: 0,\n      elements: document.getElementsByClassName('shortcut-list-item'),\n      spoilersShown: false\n    }),\n    store: () => store,\n    oncreate () {\n      addShortcutFallback(scope, this)\n    },\n    ondestroy () {\n      removeShortcutFallback(scope, this)\n    },\n    methods: {\n      onKeyDown (event) {\n        if (shouldIgnoreEvent(event)) {\n          return\n        }\n        if (event.key === 'z' && this.store.get().currentTimeline.startsWith('status/')) {\n          // if we're in a thread, toggle all content warnings on or off\n          event.stopPropagation()\n          event.preventDefault()\n          const { spoilersShown } = this.get()\n          emit('toggleAllSpoilers', !spoilersShown)\n          this.set({ spoilersShown: !spoilersShown })\n          return\n        }\n        if (event.key === 'j' || event.key === 'ArrowDown') {\n          event.stopPropagation()\n          event.preventDefault()\n          this.changeActiveItem(1, event.timeStamp)\n          return\n        }\n        if (event.key === 'k' || event.key === 'ArrowUp') {\n          event.stopPropagation()\n          event.preventDefault()\n          this.changeActiveItem(-1, event.timeStamp)\n          return\n        }\n        let activeItemKey = this.checkActiveItem(event.timeStamp)\n        if (!activeItemKey) {\n          const { elements } = this.get()\n          const index = firstVisibleElementIndex(elements).first\n          if (index >= 0) {\n            activeItemKey = elementToKey(elements[index])\n          }\n        }\n        if (activeItemKey) {\n          onKeyDownInShortcutScope(activeItemKey, event)\n        }\n      },\n      changeActiveItem (movement, timeStamp) {\n        const { elements } = this.get()\n        let index = -1\n        let activeItemKey = this.checkActiveItem(timeStamp)\n        if (activeItemKey) {\n          const len = elements.length\n          let i = -1\n          while (++i < len) {\n            if (elementToKey(elements[i]) === activeItemKey) {\n              index = i\n              break\n            }\n          }\n        }\n        if (index === 0 && movement === -1) {\n          activeItemKey = null\n          this.set({ activeItemKey })\n          smoothScroll(getScrollContainer(), 0, /* horizontal */ false, /* preferFast */ false)\n          return\n        }\n        if (index === -1) {\n          const { first, firstComplete } = firstVisibleElementIndex(elements)\n          index = (movement > 0) ? firstComplete : first\n        } else {\n          index += movement\n        }\n        if (index >= 0 && index < elements.length) {\n          activeItemKey = elementToKey(elements[index])\n          this.setActiveItem(activeItemKey, timeStamp)\n          scrollIntoViewIfNeeded(keyToElement(activeItemKey))\n        }\n      },\n      checkActiveItem (timeStamp) {\n        const activeElement = document.activeElement\n        if (!activeElement) {\n          return null\n        }\n        // The user might be focused on an element inside a toot. We want to\n        // move relative to that toot.\n        const activeArticle = activeElement.closest('article')\n        if (!activeArticle) {\n          return null\n        }\n        const activeItem = activeArticle.getAttribute('id')\n        if (!activeItem) {\n          return null\n        }\n        const { activeItemChangeTime } = this.get()\n        if ((timeStamp - activeItemChangeTime) > VISIBILITY_CHECK_DELAY_MS &&\n            !isVisible(keyToElement(activeItem))) {\n          this.setActiveItem(null, 0)\n          return null\n        }\n        return activeItem\n      },\n      setActiveItem (key, timeStamp) {\n        this.set({ activeItemChangeTime: timeStamp })\n        try {\n          keyToElement(key).focus({\n            preventScroll: true\n          })\n        } catch (err) {\n          console.error('Ignored focus error', err)\n        }\n      }\n    }\n  }\n</script>\n","import { database } from '../_database/database.js'\nimport { mark, stop } from '../_utils/marks.js'\nimport { prepareToRehydrate, rehydrateStatusOrNotification } from './rehydrateStatusOrNotification.js'\n\nasync function getNotification (instanceName, timelineType, timelineValue, itemId) {\n  return {\n    timelineType,\n    timelineValue,\n    notification: await database.getNotification(instanceName, itemId)\n  }\n}\n\nasync function getStatus (instanceName, timelineType, timelineValue, itemId) {\n  return {\n    timelineType,\n    timelineValue,\n    status: await database.getStatus(instanceName, itemId)\n  }\n}\n\nexport function createMakeProps (instanceName, timelineType, timelineValue) {\n  let promiseChain = Promise.resolve()\n\n  prepareToRehydrate() // start blurhash early to save time\n\n  async function fetchFromIndexedDB (itemId) {\n    mark(`fetchFromIndexedDB-${itemId}`)\n    try {\n      const res = await (timelineType === 'notifications'\n        ? getNotification(instanceName, timelineType, timelineValue, itemId)\n        : getStatus(instanceName, timelineType, timelineValue, itemId))\n      return res\n    } finally {\n      stop(`fetchFromIndexedDB-${itemId}`)\n    }\n  }\n\n  async function getStatusOrNotification (itemId) {\n    const statusOrNotification = await fetchFromIndexedDB(itemId)\n    await rehydrateStatusOrNotification(statusOrNotification)\n    return statusOrNotification\n  }\n\n  // The results from IndexedDB or the worker thread can return in random order,\n  // so we ensure consistent ordering based on the order this function is called in.\n  return itemId => {\n    const getStatusOrNotificationPromise = getStatusOrNotification(itemId) // start the promise ASAP\n    return new Promise((resolve, reject) => {\n      promiseChain = promiseChain\n        .then(() => getStatusOrNotificationPromise)\n        .then(resolve, reject)\n    })\n  }\n}\n","<DynamicHeading className=\"sr-only\" level={headingLevel}>{label}</DynamicHeading>\n<FocusRestoration realm={focusRealm}>\n  <div class=\"timeline\" role=\"feed\">\n    {#if components}\n      <svelte:component this={components.listComponent}\n                  component={components.listItemComponent}\n                  realm=\"{$currentInstance + '/' + timeline}\"\n                  {makeProps}\n                  items={itemIds}\n                  showFooter={true}\n                  footerComponent={LoadingFooter}\n                  showHeader={$showHeader}\n                  headerComponent={MoreHeaderVirtualWrapper}\n                  {headerProps}\n                  {scrollToItem}\n                  on:scrollToBottom=\"onScrollToBottom()\"\n                  on:scrollToTop=\"onScrollToTop()\"\n                  on:scrollTopChanged=\"onScrollTopChanged(event)\"\n                  on:initialized=\"initialize()\"\n                  on:noNeedToScroll=\"onNoNeedToScroll()\"\n      />\n    {/if}\n  </div>\n</FocusRestoration>\n<Shortcut scope=\"global\" key=\".\" on:pressed=\"showMoreAndScrollToTop()\" />\n<ScrollListShortcuts />\n<script>\n  import { store } from '../../_store/store.js'\n  import DynamicHeading from '../DynamicHeading.html'\n  import Status from '../status/Status.html'\n  import LoadingFooter from './LoadingFooter.html'\n  import MoreHeaderVirtualWrapper from './MoreHeaderVirtualWrapper.html'\n  import ScrollListShortcuts from '../shortcut/ScrollListShortcuts.html'\n  import Shortcut from '../shortcut/Shortcut.html'\n  import { importVirtualList } from '../../_utils/asyncModules/importVirtualList.js'\n  import { importList } from '../../_utils/asyncModules/importList.js'\n  import { importStatusVirtualListItem } from '../../_utils/asyncModules/importStatusVirtualListItem.js'\n  import { importNotificationVirtualListItem } from '../../_utils/asyncModules/importNotificationVirtualListItem.js'\n  import { timelines } from '../../_static/timelines.js'\n  import {\n    fetchMoreItemsAtBottomOfTimeline,\n    setupTimeline,\n    showMoreItemsForTimeline,\n    showMoreItemsForThread,\n    showMoreItemsForCurrentTimeline\n  } from '../../_actions/timeline.js'\n  import { scheduleIdleTask } from '../../_utils/scheduleIdleTask.js'\n  import { mark, stop } from '../../_utils/marks.js'\n  import { isEqual } from '../../_thirdparty/lodash/objects.js'\n  import { doubleRAF } from '../../_utils/doubleRAF.js'\n  import { observe } from 'svelte-extras'\n  import { createMakeProps } from '../../_actions/createMakeProps.js'\n  import { showMoreAndScrollToTop } from '../../_actions/showMoreAndScrollToTop.js'\n  import FocusRestoration from '../FocusRestoration.html'\n  import { formatIntl } from '../../_utils/formatIntl.js'\n\n  export default {\n    oncreate () {\n      console.log('timeline oncreate()')\n      setupTimeline()\n      this.setupStreaming()\n      this.setupAsyncComponents()\n    },\n    data: () => ({\n      LoadingFooter,\n      MoreHeaderVirtualWrapper,\n      Status,\n      scrollTop: 0,\n      components: undefined\n    }),\n    computed: {\n      // For threads, it's simpler to just render all items as a pseudo-virtual list\n      // due to need to scroll to the right item and thus calculate all item heights up-front.\n      // Here we lazy-load both the virtual list component itself as well as the component\n      // it renders.\n      componentsPromise: ({ timelineType }) => {\n        return Promise.all([\n          timelineType === 'status'\n            ? importList()\n            : importVirtualList(),\n          timelineType === 'notifications'\n            ? importNotificationVirtualListItem()\n            : importStatusVirtualListItem()\n        ]).then(results => ({\n          listComponent: results[0],\n          listItemComponent: results[1]\n        }))\n      },\n      makeProps: ({ $currentInstance, timelineType, timelineValue }) => (\n        createMakeProps($currentInstance, timelineType, timelineValue)\n      ),\n      label: ({ timeline, $currentInstance, timelineType, timelineValue }) => {\n        if (timelines[timeline]) {\n          return formatIntl([\"Statuses: \",[\"timeline\"],\" timeline on \",[\"instance\"]], {\n            timeline: timelines[timeline].label,\n            instance: $currentInstance\n          })\n        }\n\n        switch (timelineType) {\n          case 'tag':\n            return formatIntl([\"Statuses: #\",[\"hashtag\"],\" hashtag\"], { hashtag: timelineValue })\n          case 'status':\n            return \"Statuses: thread\"\n          case 'account':\n            return \"Statuses: account timeline\"\n          case 'list':\n            return \"Statuses: list\"\n          case 'notifications':\n            return formatIntl([\"Notifications on \",[\"instance\"]], { instance: $currentInstance })\n        }\n      },\n      timelineType: ({ $currentTimelineType }) => $currentTimelineType,\n      timelineValue: ({ $currentTimelineValue }) => $currentTimelineValue,\n      // Scroll to the first item if this is a \"status in own thread\" timeline.\n      // Don't scroll to the first item because it obscures the \"back\" button.\n      scrollToItem: ({ timelineType, timelineValue, $firstTimelineItemId }) => (\n        timelineType === 'status' &&\n        $firstTimelineItemId &&\n        timelineValue !== $firstTimelineItemId &&\n        timelineValue\n      ),\n      itemIds: ({ $filteredTimelineItemSummaries }) => (\n        $filteredTimelineItemSummaries && $filteredTimelineItemSummaries.map(_ => _.id)\n      ),\n      itemIdsToAdd: ({ $filteredTimelineItemSummariesToAdd }) => (\n        $filteredTimelineItemSummariesToAdd && $filteredTimelineItemSummariesToAdd.map(_ => _.id)\n      ),\n      headerProps: ({ itemIdsToAdd }) => {\n        return {\n          count: itemIdsToAdd ? itemIdsToAdd.length : 0,\n          onClick: showMoreItemsForCurrentTimeline\n        }\n      },\n      focusRealm: ({ $currentInstance, timeline }) => `${$currentInstance}-${timeline}`,\n      headingLevel: ({ timeline, timelineType }) => timeline === 'home' || timelineType === 'status' ? 2 : 1\n    },\n    store: () => store,\n    methods: {\n      observe,\n      initialize () {\n        const { initializeStarted } = this.get()\n        if (initializeStarted) {\n          return\n        }\n        this.set({ initializeStarted: true })\n        mark('initializeTimeline')\n        doubleRAF(() => {\n          console.log('timeline initialized')\n          this.store.set({ timelineInitialized: true })\n          stop('initializeTimeline')\n        })\n      },\n      onScrollTopChanged (scrollTop) {\n        this.set({ scrollTop })\n      },\n      onScrollToBottom () {\n        const { timelineType } = this.get()\n        const { timelineInitialized, runningUpdate, disableInfiniteScroll } = this.store.get()\n        if (!timelineInitialized ||\n            runningUpdate ||\n            disableInfiniteScroll ||\n            timelineType === 'status') { // for status contexts, we've already fetched the whole thread\n          return\n        }\n        const { currentInstance } = this.store.get()\n        const { timeline } = this.get()\n        /* no await */ fetchMoreItemsAtBottomOfTimeline(currentInstance, timeline)\n      },\n      onScrollToTop () {\n        const { shouldShowHeader } = this.store.get()\n        if (shouldShowHeader) {\n          this.store.setForCurrentTimeline({\n            showHeader: true,\n            shouldShowHeader: false\n          })\n        }\n      },\n      setupStreaming () {\n        const { currentInstance, disableInfiniteScroll } = this.store.get()\n        const { timeline, timelineType } = this.get()\n        const handleItemIdsToAdd = () => {\n          const { itemIdsToAdd } = this.get()\n          if (!itemIdsToAdd || !itemIdsToAdd.length) {\n            return\n          }\n          mark('handleItemIdsToAdd')\n          const { scrollTop } = this.get()\n          const {\n            shouldShowHeader,\n            showHeader\n          } = this.store.get()\n          if (timelineType === 'status') {\n            // this is a thread, just insert the statuses already\n            showMoreItemsForThread(currentInstance, timeline)\n          } else if (!disableInfiniteScroll && scrollTop === 0 && !shouldShowHeader && !showHeader) {\n            // if the user is scrolled to the top and we're not showing the header, then\n            // just insert the statuses. this is \"chat room mode\"\n            showMoreItemsForTimeline(currentInstance, timeline)\n          } else {\n            // user hasn't scrolled to the top, show a header instead\n            this.store.setForTimeline(currentInstance, timeline, { shouldShowHeader: true })\n            // unless the user has disabled infinite scroll entirely\n            if (disableInfiniteScroll) {\n              this.store.setForTimeline(currentInstance, timeline, { showHeader: true })\n            }\n          }\n          stop('handleItemIdsToAdd')\n        }\n        this.observe('itemIdsToAdd', (newItemIdsToAdd, oldItemIdsToAdd) => {\n          if (!newItemIdsToAdd ||\n              !newItemIdsToAdd.length ||\n              isEqual(newItemIdsToAdd, oldItemIdsToAdd)) {\n            return\n          }\n          scheduleIdleTask(handleItemIdsToAdd)\n        })\n      },\n      setupAsyncComponents () {\n        this.observe('componentsPromise', async componentsPromise => {\n          if (componentsPromise) {\n            console.log('loading timeline components')\n            const components = await componentsPromise\n            console.log('loaded timeline components')\n            this.set({ components })\n          }\n        })\n      },\n      onNoNeedToScroll () {\n        // If the timeline doesn't need to scroll, then we can safely \"preinitialize,\"\n        // i.e. render anything above the fold of the timeline. This avoids the affect\n        // where the scrollable content appears to jump around if we need to scroll it.\n        console.log('timeline preinitialized')\n        this.store.set({ timelinePreinitialized: true })\n      },\n      showMoreAndScrollToTop\n    },\n    components: {\n      ScrollListShortcuts,\n      Shortcut,\n      FocusRestoration,\n      DynamicHeading\n    }\n  }\n</script>\n","import { showMoreItemsForCurrentTimeline } from './timeline.js'\nimport { scrollToTop } from '../_utils/scrollToTop.js'\nimport { createStatusOrNotificationUuid } from '../_utils/createStatusOrNotificationUuid.js'\nimport { store } from '../_store/store.js'\nimport { tryToFocusElement } from '../_utils/tryToFocusElement.js'\n\nexport function showMoreAndScrollToTop () {\n  // Similar to Twitter, pressing \".\" will click the \"show more\" button and select\n  // the first toot.\n  showMoreItemsForCurrentTimeline()\n  const {\n    currentInstance,\n    timelineItemSummaries,\n    currentTimelineType,\n    currentTimelineValue\n  } = store.get()\n  const firstItemSummary = timelineItemSummaries && timelineItemSummaries[0]\n  if (!firstItemSummary) {\n    return\n  }\n  const notificationId = currentTimelineType === 'notifications' && firstItemSummary.id\n  const statusId = currentTimelineType !== 'notifications' && firstItemSummary.id\n  scrollToTop(/* smooth */ false)\n  const id = createStatusOrNotificationUuid(\n    currentInstance, currentTimelineType,\n    currentTimelineValue, notificationId, statusId\n  )\n  tryToFocusElement(id)\n}\n","export const importList = () => import(\n  '../../_components/list/List.html'\n).then(mod => mod.default)\n","export const importVirtualList = () => import(\n  '../../_components/virtualList/VirtualList.html'\n).then(mod => mod.default)\n","export const importNotificationVirtualListItem = () => import(\n  '../../_components/timeline/NotificationVirtualListItem.html'\n).then(mod => mod.default)\n","export const importStatusVirtualListItem = () => import(\n  '../../_components/timeline/StatusVirtualListItem.html'\n).then(mod => mod.default)\n","import { getWithHeaders, paramsString, DEFAULT_TIMEOUT } from '../_utils/ajax.js'\nimport { auth, basename } from './utils.js'\n\nfunction getTimelineUrlPath (timeline) {\n  switch (timeline) {\n    case 'local':\n    case 'federated':\n      return 'timelines/public'\n    case 'home':\n      return 'timelines/home'\n    case 'notifications':\n    case 'notifications/mentions':\n      return 'notifications'\n    case 'favorites':\n      return 'favourites'\n    case 'direct':\n      return 'conversations'\n    case 'bookmarks':\n      return 'bookmarks'\n  }\n  if (timeline.startsWith('tag/')) {\n    return 'timelines/tag'\n  } else if (timeline.startsWith('account/')) {\n    return 'accounts'\n  } else if (timeline.startsWith('list/')) {\n    return 'timelines/list'\n  }\n  throw new Error(`Invalid timeline type: ${timeline}`)\n}\n\nexport async function getTimeline (instanceName, accessToken, timeline, maxId, since, limit) {\n  const timelineUrlName = getTimelineUrlPath(timeline)\n  let url = `${basename(instanceName)}/api/v1/${timelineUrlName}`\n\n  if (timeline.startsWith('tag/')) {\n    url += '/' + timeline.split('/')[1]\n  } else if (timeline.startsWith('account/')) {\n    url += '/' + timeline.split('/')[1] + '/statuses'\n  } else if (timeline.startsWith('list/')) {\n    url += '/' + timeline.split('/')[1]\n  }\n\n  const params = {}\n  if (since) {\n    params.since_id = since\n  }\n\n  if (maxId) {\n    params.max_id = maxId\n  }\n\n  if (limit) {\n    params.limit = limit\n  }\n\n  if (timeline === 'local') {\n    params.local = true\n  }\n\n  if (timeline.startsWith('account/')) {\n    if (timeline.endsWith('media')) {\n      params.only_media = true\n    } else {\n      params.exclude_replies = !timeline.endsWith('/with_replies')\n    }\n  }\n\n  if (timeline === 'notifications/mentions') {\n    params.exclude_types = ['follow', 'favourite', 'reblog', 'poll', 'admin.sign_up', 'update', 'follow_request', 'admin.report']\n  }\n\n  url += '?' + paramsString(params)\n\n  console.log('fetching url', url)\n  let { json: items, headers } = await getWithHeaders(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n\n  if (timeline === 'direct') {\n    items = items.map(item => item.last_status).filter(Boolean) // ignore falsy last_status'es\n  }\n  return { items, headers }\n}\n","export const TIMELINE_BATCH_SIZE = 20\n\nexport const timelines = {\n  home: { name: 'home', label: \"Home\" },\n  local: { name: 'local', label: \"Local\" },\n  federated: { name: 'federated', label: \"Federated\" }\n}\n","// Pleroma uses base62 IDs, Mastodon uses 0-9 big ints encoded as strings.\n// Using base62 for both works, since the first 10 characters of base62\n// are 0-9.\n\nimport { padStart } from './lodash-lite.js'\n\n// Pleroma uses the 0-9A-Za-z alphabet for base62, which is the same as ASCII, which\n// is the same as JavaScript sort order and IndexedDB order.\nconst MIN_CHAR_CODE = 48 // '0'.charCodeAt(0)\nconst MAX_CHAR_CODE = 122 // 'z'.charCodeAt(0)\nconst MAX_ID_LENGTH = 30 // assume that Mastodon/Pleroma IDs won't get any bigger than this\n\nexport function zeroPad (str, toSize) {\n  return padStart(str, toSize, '0')\n}\n\nexport function toPaddedBigInt (id) {\n  return zeroPad(id, MAX_ID_LENGTH)\n}\n\nexport function toReversePaddedBigInt (id) {\n  const padded = toPaddedBigInt(id)\n  let reversed = ''\n  for (let i = 0; i < padded.length; i++) {\n    const charCode = padded.charCodeAt(i)\n    const inverseCharCode = MIN_CHAR_CODE + MAX_CHAR_CODE - charCode\n    reversed += String.fromCharCode(inverseCharCode)\n  }\n  return reversed\n}\n\nexport function compareTimelineItemSummaries (left, right) {\n  const leftPadded = toPaddedBigInt(left.id)\n  const rightPadded = toPaddedBigInt(right.id)\n  return leftPadded < rightPadded ? -1 : leftPadded === rightPadded ? 0 : 1\n}\n"],"names":["relsRegExp","sourceRegExp","delimiterRegExp","parse","linksHeader","options","match","source","rels","extended","links","trim","exec","current","link","nextDelimiter","slice","length","index","split","push","replace","reduce","result","currentLink","rel","forEach","stringify","params","grouped","Object","keys","key","concat","join","this","module","exports","definition","context","className","level","sortItemSummariesForThread","summaries","statusId","ancestors","descendants","summariesById","items","func","map","Map","item","set","mapBy","_","id","summariesByReplyId","has","get","multimapBy","replyId","status","currentStatus","unshift","stack","shift","newChildren","sort","Array","prototype","apply","isUnbrokenSelfReply","descendant","accountId","parent","promotedDescendants","otherDescendants","byId","async","storeFreshTimelineItemsInDatabase","instanceName","timelineName","database","startsWith","updateStatus","accessToken","fetchThreadFromNetwork","Promise","all","fetchFreshThreadFromNetwork","in_reply_to_id","updateStatusAndThread","scheduleIdleTask","addPagedTimelineItems","newSummaries","timelineItemToSummary","oldSummaries","store","mergedSummaries","timelineItemSummaries","addPagedTimelineItemSummaries","s","fetchTimelineItems","online","lastTimelineItemId","stale","fetchTimelineItemsFromNetwork","e","console","error","toast","addTimelineItemSummaries","newStale","oldStale","timelineItemSummariesAreStale","fetchTimelineItemsAndPossiblyFallBack","currentTimeline","currentInstance","timelineNextPageId","headers","linkHeader","parsedLinkHeader","nextUrl","next","nextId","URL","searchParams","fetchPagedItems","addTimelineItems","fetchMoreItemsAtBottomOfTimeline","runningUpdate","showMoreItemsForTimeline","itemSummariesToAdd","reverse","timelineItemSummariesToAdd","shouldShowHeader","showHeader","showMoreItemsForCurrentTimeline","observe","onClickLoadMore","preventDefault","stopPropagation","virtualListItems","document","querySelector","children","focus","delayedAriaAnnouncementHandle","showLoading","setTimeout","undefined","announceAriaLivePolite","clearTimeout","event","showLoadButton","shown","$timelineInitialized","$runningUpdate","$disableInfiniteScroll","onClick","showMoreLabel","count","formatIntl","virtualProps","mainNavElement","getTopOverlay","getElementById","clientHeight","firstVisibleElementIndex","elements","offsetHeight","topOverlay","first","firstComplete","len","i","element","rect","getBoundingClientRect","top","bottom","keyToElement","elementToKey","getAttribute","scope","onKeyDown","target","tagName","type","isArrow","shouldIgnoreEvent","spoilersShown","changeActiveItem","timeStamp","activeItemKey","checkActiveItem","movement","smoothScroll","setActiveItem","scrollY","height","scrollContainer","scrollTop","scrollIntoViewIfNeeded","activeElement","activeArticle","closest","activeItem","activeItemChangeTime","isVisible","preventScroll","err","getElementsByClassName","createMakeProps","timelineType","timelineValue","promiseChain","resolve","fetchFromIndexedDB","itemId","res","notification","getNotification","getStatus","getStatusOrNotificationPromise","statusOrNotification","rehydrateStatusOrNotification","getStatusOrNotification","reject","then","initialize","initializeStarted","doubleRAF","timelineInitialized","onScrollTopChanged","onScrollToBottom","disableInfiniteScroll","timeline","onScrollToTop","setForCurrentTimeline","setupStreaming","handleItemIdsToAdd","itemIdsToAdd","timelineItemIds","Set","itemSummaryToAdd","sortedTimelineItemSummaries","showMoreItemsForThread","setForTimeline","newItemIdsToAdd","oldItemIdsToAdd","setupAsyncComponents","componentsPromise","components","onNoNeedToScroll","timelinePreinitialized","showMoreAndScrollToTop","currentTimelineType","currentTimelineValue","firstItemSummary","notificationId","scrollToTop","createStatusOrNotificationUuid","tryToFocusElement","setupTimeline","listComponent","listItemComponent","$currentInstance","makeProps","itemIds","LoadingFooter","$showHeader","MoreHeaderVirtualWrapper","headerProps","scrollToItem","Status","headingLevel","focusRealm","label","$currentTimelineType","mod","default","results","$currentTimelineValue","instance","hashtag","$firstTimelineItemId","$filteredTimelineItemSummaries","$filteredTimelineItemSummariesToAdd","getTimeline","maxId","since","limit","timelineUrlName","Error","getTimelineUrlPath","url","since_id","max_id","local","endsWith","only_media","exclude_replies","exclude_types","json","timeout","last_status","filter","Boolean","TIMELINE_BATCH_SIZE","timelines","home","name","federated","zeroPad","str","toSize","toPaddedBigInt","toReversePaddedBigInt","padded","reversed","inverseCharCode","MIN_CHAR_CODE","charCodeAt","String","fromCharCode","compareTimelineItemSummaries","left","right","leftPadded","rightPadded"],"sourceRoot":""}