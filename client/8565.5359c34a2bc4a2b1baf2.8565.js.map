{"version":3,"file":"8565.5359c34a2bc4a2b1baf2.8565.js","mappings":"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","sources":["webpack://semaphore/./src/routes/_components/FocusRestoration.html","webpack://semaphore/./src/routes/_static/pages.js","webpack://semaphore/./src/routes/_thirdparty/quick-lru/quick-lru.js","webpack://semaphore/./src/routes/_utils/tryToFocusElement.js"],"sourcesContent":["<div\n  on:focusin=\"saveFocus(event)\"\n  on:focusout=\"clearFocus()\"\n>\n  <slot></slot>\n</div>\n<script>\n  import { PAGE_HISTORY_SIZE } from '../_static/pages.js'\n  import { QuickLRU } from '../_thirdparty/quick-lru/quick-lru.js'\n  import { tryToFocusElement } from '../_utils/tryToFocusElement.js'\n\n  const cache = new QuickLRU({ maxSize: PAGE_HISTORY_SIZE })\n\n  if (process.browser) {\n    window.__focusRestorationCache = cache\n  }\n\n  export default {\n    oncreate () {\n      this.setupPushState()\n      this.restoreFocus()\n      if (process.env.NODE_ENV !== 'production') {\n        if (!this.get().realm) {\n          throw new Error('FocusRestoration needs a realm')\n        }\n      }\n    },\n    ondestroy () {\n      this.teardownPushState()\n    },\n    methods: {\n      setupPushState () {\n        this.onPushState = this.onPushState.bind(this)\n        this.setInCache({ ignoreBlurEvents: false })\n        window.addEventListener('pushState', this.onPushState)\n      },\n      teardownPushState () {\n        window.removeEventListener('pushState', this.onPushState)\n      },\n      setInCache (obj) {\n        const { realm } = this.get()\n        if (!cache.has(realm)) {\n          cache.set(realm, {})\n        }\n        Object.assign(cache.get(realm), obj)\n      },\n      deleteInCache (key) {\n        const { realm } = this.get()\n        if (cache.has(realm)) {\n          delete cache.get(realm)[key]\n        }\n      },\n      getInCache () {\n        const { realm } = this.get()\n        return cache.get(realm) || {}\n      },\n      onPushState () {\n        this.setInCache({ ignoreBlurEvents: true })\n      },\n      restoreFocus () {\n        const { realm } = this.get()\n        const { elementId } = this.getInCache()\n        if (!elementId) {\n          return\n        }\n        console.log('restoreFocus', realm, elementId)\n        tryToFocusElement(elementId)\n      },\n      clearFocus () {\n        const { realm } = this.get()\n        const { ignoreBlurEvents } = this.getInCache()\n        if (!ignoreBlurEvents) {\n          console.log('clearFocus', realm)\n          this.deleteInCache('elementId')\n        }\n      },\n      saveFocus (e) {\n        const { realm } = this.get()\n        const element = e.target\n        if (element) {\n          const elementId = element.getAttribute('id')\n          if (elementId) {\n            console.log('saveFocus', realm, elementId)\n            this.setInCache({ elementId })\n          }\n        }\n      }\n    }\n  }\n</script>\n","export const PAGE_HISTORY_SIZE = 10\n","// Forked from https://github.com/sindresorhus/quick-lru/blob/16d15d470a8eb87c2a7dd5b80892d9b74f1acd3c/index.js\n// Adds the ability to listen for 'evict' events using an EventEmitter, also removes some unused code\n\nimport eventsLightPackage from 'events-light'\nconst { EventEmitter } = eventsLightPackage\n\nexport class QuickLRU extends EventEmitter {\n  constructor (options = {}) {\n    super()\n    if (!(options.maxSize && options.maxSize > 0)) {\n      throw new TypeError('`maxSize` must be a number greater than 0')\n    }\n\n    this.maxSize = options.maxSize\n    this.cache = new Map()\n    this.oldCache = new Map()\n    this._size = 0\n  }\n\n  _set (key, value) {\n    this.cache.set(key, value)\n    this._size++\n\n    if (this._size >= this.maxSize) {\n      this._size = 0\n      if (this.listenerCount('evict')) {\n        for (const key of this.oldCache.keys()) {\n          if (!this.cache.has(key)) {\n            this.emit('evict', this.oldCache.get(key), key)\n          }\n        }\n      }\n      this.oldCache = this.cache\n      this.cache = new Map()\n    }\n  }\n\n  get (key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key)\n    }\n\n    if (this.oldCache.has(key)) {\n      const value = this.oldCache.get(key)\n      this.oldCache.delete(key)\n      this._set(key, value)\n      return value\n    }\n  }\n\n  set (key, value) {\n    if (this.cache.has(key)) {\n      this.cache.set(key, value)\n    } else {\n      this._set(key, value)\n    }\n\n    return this\n  }\n\n  has (key) {\n    return this.cache.has(key) || this.oldCache.has(key)\n  }\n\n  // unused\n  // peek (key) {\n  //   if (this.cache.has(key)) {\n  //     return this.cache.get(key)\n  //   }\n  //\n  //   if (this.oldCache.has(key)) {\n  //     return this.oldCache.get(key)\n  //   }\n  // }\n\n  delete (key) {\n    const deleted = this.cache.delete(key)\n    if (deleted) {\n      this._size--\n    }\n\n    return this.oldCache.delete(key) || deleted\n  }\n\n  clear () {\n    this.cache.clear()\n    this.oldCache.clear()\n    this._size = 0\n  }\n\n  getAllKeys () {\n    const set = new Set()\n    for (const key of this.cache.keys()) {\n      set.add(key)\n    }\n    for (const key of this.oldCache.keys()) {\n      set.add(key)\n    }\n    return set\n  }\n\n  // unused\n  // * keys() {\n  //   for (const [key] of this) {\n  //     yield key;\n  //   }\n  // }\n  //\n  // * values() {\n  //   for (const [, value] of this) {\n  //     yield value;\n  //   }\n  // }\n  //\n  // * [Symbol.iterator]() {\n  //   for (const item of this.cache) {\n  //     yield item;\n  //   }\n  //\n  //   for (const item of this.oldCache) {\n  //     const [key] = item;\n  //     if (!this.cache.has(key)) {\n  //       yield item;\n  //     }\n  //   }\n  // }\n  //\n  // get size () {\n  //   let oldCacheSize = 0\n  //   for (const key of this.oldCache.keys()) {\n  //     if (!this.cache.has(key)) {\n  //       oldCacheSize++\n  //     }\n  //   }\n  //\n  //   return this._size + oldCacheSize\n  // }\n}\n","// try 5 times to wait for the element to be rendered and then focus it\nimport { scheduleIdleTask } from './scheduleIdleTask.js'\n\nconst RETRIES = 5\nconst TIMEOUT = 50\n\nexport async function tryToFocusElement (id, scroll) {\n  for (let i = 0; i < RETRIES; i++) {\n    if (i > 0) {\n      await new Promise(resolve => setTimeout(resolve, TIMEOUT))\n    }\n    await new Promise(resolve => scheduleIdleTask(resolve))\n    const element = document.getElementById(id)\n    if (element) {\n      try {\n        element.focus({ preventScroll: !scroll })\n        console.log('focused element', id)\n        return\n      } catch (e) {\n        console.error(e)\n      }\n    }\n  }\n  console.log('failed to focus element', id)\n}\n"],"names":["cache","maxSize","window","__focusRestorationCache","setupPushState","this","onPushState","bind","setInCache","ignoreBlurEvents","addEventListener","teardownPushState","removeEventListener","obj","realm","get","has","set","Object","assign","deleteInCache","key","getInCache","restoreFocus","elementId","clearFocus","saveFocus","e","element","target","getAttribute","event","PAGE_HISTORY_SIZE","EventEmitter","QuickLRU","constructor","options","super","TypeError","Map","oldCache","_size","_set","value","listenerCount","keys","emit","delete","deleted","clear","getAllKeys","Set","add","async","tryToFocusElement","id","scroll","i","Promise","resolve","setTimeout","document","getElementById","focus","preventScroll","console","error"],"sourceRoot":""}