{"version":3,"file":"3754.037f4c59dea116fc9d09.settings_instances_add.js","mappings":"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","sources":["webpack://semaphore/./src/routes/_api/oauth.js","webpack://semaphore/./src/routes/_static/blocks.js","webpack://semaphore/./src/routes/_actions/addInstance.js","webpack://semaphore/./src/routes/_pages/settings/instances/add.html","webpack://semaphore/./src/routes/settings/instances/add.html","webpack://semaphore/./src/routes/_actions/emoji.js","webpack://semaphore/./src/routes/_api/emoji.js","webpack://semaphore/./src/routes/_api/user.js","webpack://semaphore/./src/routes/_utils/asyncModules/importDatabase.js","webpack://semaphore/./src/routes/_database/asyncDatabase.js","webpack://semaphore/./src/routes/_utils/sync.js"],"sourcesContent":["import { post, paramsString, WRITE_TIMEOUT } from '../_utils/ajax.js'\nimport { basename } from './utils.js'\n\nconst WEBSITE = 'https://semaphore.social'\nconst SCOPES = 'read write follow push'\nconst CLIENT_NAME = 'Semaphore'\n\nexport function registerApplication (instanceName, redirectUri) {\n  const url = `${basename(instanceName)}/api/v1/apps`\n  return post(url, {\n    client_name: CLIENT_NAME,\n    redirect_uris: redirectUri,\n    scopes: SCOPES,\n    website: WEBSITE\n  }, null, { timeout: WRITE_TIMEOUT })\n}\n\nexport function generateAuthLink (instanceName, clientId, redirectUri) {\n  const params = paramsString({\n    client_id: clientId,\n    redirect_uri: redirectUri,\n    response_type: 'code',\n    scope: SCOPES\n  })\n  return `${basename(instanceName)}/oauth/authorize?${params}`\n}\n\nexport function getAccessTokenFromAuthCode (instanceName, clientId, clientSecret, code, redirectUri) {\n  const url = `${basename(instanceName)}/oauth/token`\n  // Using URLSearchParams here guarantees a content type of application/x-www-form-urlencoded\n  // See https://fetch.spec.whatwg.org/#bodyinit-unions\n  return post(url, new URLSearchParams({\n    client_id: clientId,\n    client_secret: clientSecret,\n    redirect_uri: redirectUri,\n    grant_type: 'authorization_code',\n    code\n  }), null, { timeout: WRITE_TIMEOUT })\n}\n","export const DOMAIN_BLOCKS = [\n  'gab.com',\n  'gab.ai'\n]\n","import { getAccessTokenFromAuthCode, registerApplication, generateAuthLink } from '../_api/oauth.js'\nimport { getInstanceInfo } from '../_api/instance.js'\nimport { goto } from '../../../__sapper__/client.js'\nimport { DEFAULT_THEME, switchToTheme } from '../_utils/themeEngine.js'\nimport { store } from '../_store/store.js'\nimport { updateVerifyCredentialsForInstance } from './instances.js'\nimport { updateCustomEmojiForInstance } from './emoji.js'\nimport { database } from '../_database/database.js'\nimport { DOMAIN_BLOCKS } from '../_static/blocks.js'\n\nconst GENERIC_ERROR = `\n  Is this a valid Mastodon instance? Is a browser extension\n  blocking the request? Are you in private browsing mode?\n  If you believe this is a problem with your instance, please send\n  <a href=\"https://github.com/NickColley/semaphore/blob/main/docs/Admin-Guide.md\"\n    target=\"_blank\" rel=\"noopener\">this link</a> to the administrator of your instance.`\n\nfunction createKnownError (message) {\n  const err = new Error(message)\n  err.knownError = true\n  return err\n}\n\nfunction getRedirectUri () {\n  return `${location.origin}/settings/instances/add`\n}\n\nasync function redirectToOauth () {\n  let { instanceNameInSearch, loggedInInstances } = store.get()\n  instanceNameInSearch = instanceNameInSearch.replace(/^https?:\\/\\//, '').replace(/\\/+$/, '').toLowerCase()\n  if (Object.keys(loggedInInstances).includes(instanceNameInSearch)) {\n    throw createKnownError(`You've already logged in to ${instanceNameInSearch}`)\n  }\n  const instanceHostname = new URL(`http://${instanceNameInSearch}`).hostname\n  if (DOMAIN_BLOCKS.some(domain => new RegExp(`(?:\\\\.|^)${domain}$`, 'i').test(instanceHostname))) {\n    throw createKnownError('This service is blocked')\n  }\n  const redirectUri = getRedirectUri()\n  const registrationPromise = registerApplication(instanceNameInSearch, redirectUri)\n  try {\n    const instanceInfo = await getInstanceInfo(instanceNameInSearch)\n    await database.setInstanceInfo(instanceNameInSearch, instanceInfo) // cache for later\n  } catch (err) {\n    // We get a 401 in limited federation mode, so we can just skip setting the instance info in that case.\n    // It will be fetched automatically later.\n    if (err.status !== 401) {\n      throw err // this is a good way to test for typos in the instance name or some other problem\n    }\n  }\n  const instanceData = await registrationPromise\n  store.set({\n    currentRegisteredInstanceName: instanceNameInSearch,\n    currentRegisteredInstance: instanceData\n  })\n  store.save()\n  const oauthUrl = generateAuthLink(\n    instanceNameInSearch,\n    instanceData.client_id,\n    redirectUri\n  )\n  // setTimeout to allow the browser to *actually* save the localStorage data (fixes Safari bug apparently)\n  setTimeout(() => {\n    document.location.href = oauthUrl\n  }, 200)\n}\n\nexport async function logInToInstance () {\n  store.set({\n    logInToInstanceLoading: true,\n    logInToInstanceError: null\n  })\n  try {\n    await redirectToOauth()\n  } catch (err) {\n    console.error(err)\n    const error = `${err.message || err.name}. ` +\n      (err.knownError ? '' : (navigator.onLine ? GENERIC_ERROR : 'Are you offline?'))\n    const { instanceNameInSearch } = store.get()\n    store.set({\n      logInToInstanceError: error,\n      logInToInstanceErrorForText: instanceNameInSearch\n    })\n  } finally {\n    store.set({ logInToInstanceLoading: false })\n  }\n}\n\nasync function registerNewInstance (code) {\n  const { currentRegisteredInstanceName, currentRegisteredInstance } = store.get()\n  const redirectUri = getRedirectUri()\n  const instanceData = await getAccessTokenFromAuthCode(\n    currentRegisteredInstanceName,\n    currentRegisteredInstance.client_id,\n    currentRegisteredInstance.client_secret,\n    code,\n    redirectUri\n  )\n  const { loggedInInstances, loggedInInstancesInOrder, instanceThemes } = store.get()\n  instanceThemes[currentRegisteredInstanceName] = DEFAULT_THEME\n  loggedInInstances[currentRegisteredInstanceName] = instanceData\n  if (!loggedInInstancesInOrder.includes(currentRegisteredInstanceName)) {\n    loggedInInstancesInOrder.push(currentRegisteredInstanceName)\n  }\n  store.set({\n    instanceNameInSearch: '',\n    currentRegisteredInstanceName: null,\n    currentRegisteredInstance: null,\n    loggedInInstances,\n    currentInstance: currentRegisteredInstanceName,\n    loggedInInstancesInOrder,\n    instanceThemes\n  })\n  store.save()\n  const { enableGrayscale } = store.get()\n  switchToTheme(DEFAULT_THEME, enableGrayscale)\n  // fire off these requests so they're cached\n  /* no await */ updateVerifyCredentialsForInstance(currentRegisteredInstanceName)\n  /* no await */ updateCustomEmojiForInstance(currentRegisteredInstanceName)\n  goto('/')\n}\n\nexport async function handleOauthCode (code) {\n  try {\n    store.set({ logInToInstanceLoading: true })\n    await registerNewInstance(code)\n  } catch (err) {\n    store.set({ logInToInstanceError: `${err.message || err.name}. Failed to connect to instance.` })\n  } finally {\n    store.set({ logInToInstanceLoading: false })\n  }\n}\n","<SettingsLayout page='settings/instances/add' label={pageLabel}>\n  <h1 id=\"add-an-instance-h1\">{pageLabel}</h1>\n\n  <div class=\"add-new-instance\">\n    <form on:submit='onSubmitInstance(event)' aria-labelledby=\"add-an-instance-h1\">\n\n      {#if !hasIndexedDB || !hasLocalStorage}\n        <div class=\"form-error form-error-user-error\" role=\"alert\">\n          It seems Semaphore cannot store data locally. Is your browser in private mode or blocking cookies? Semaphore stores all data locally, and requires LocalStorage and IndexedDB to work correctly.\n        </div>\n      {/if}\n\n      {#if $logInToInstanceError && $logInToInstanceErrorForText === $instanceNameInSearch}\n        <div class=\"form-error form-error-user-error\" role=\"alert\">\n          Error: {@html $logInToInstanceError}\n        </div>\n      {/if}\n\n      <noscript>\n        <div class=\"form-error\" role=\"alert\">\n          You must enable JavaScript to log in.\n        </div>\n      </noscript>\n\n      <label for=\"instanceInput\">Instance:</label>\n      <input type=\"text\" inputmode=\"url\" autocapitalize=\"none\" spellcheck=\"false\" id=\"instanceInput\"\n             bind:value='$instanceNameInSearch' placeholder=\"Enter instance name\" required\n      >\n      <button class=\"primary\" type=\"submit\" id=\"submitButton\"\n              disabled={!$instanceNameInSearch || $logInToInstanceLoading}>\n        Log in\n      </button>\n    </form>\n  </div>\n\n  {#if !$isUserLoggedIn}\n    <p>\n      Don't have an\n      <Tooltip\n        text=\"instance\"\n        tooltipText=\"An instance is your Mastodon home server, such as mastodon.social or cybre.space.\"\n      />\n      ?\n      <a rel=\"noopener\" target=\"_blank\" href=\"https://joinmastodon.org\">Join Mastodon!</a>\n    </p>\n  {/if}\n</SettingsLayout>\n<style>\n  .add-new-instance {\n    background: var(--form-bg);\n    padding: 5px 10px 15px;\n    margin: 20px auto;\n    border: 1px solid var(--form-border);\n    border-radius: 4px;\n  }\n\n  .form-error {\n    border: 2px solid var(--warn-color);\n    border-radius: 2px;\n    padding: 10px;\n    font-size: 1.3em;\n    margin: 5px;\n    background-color: var(--main-bg);\n  }\n  input {\n    min-width: 70%;\n    max-width: 100%;\n    background-color: var(--input-bg);\n  }\n\n  label, input, button, :global(.add-new-instance-aside) {\n    display: block;\n    margin: 20px 5px;\n  }\n\n  @media (max-width: 767px) {\n    input {\n      min-width: 95%;\n    }\n  }\n\n</style>\n<script>\n  import SettingsLayout from '../../../_components/settings/SettingsLayout.html'\n  import { store } from '../../../_store/store.js'\n  import { logInToInstance, handleOauthCode } from '../../../_actions/addInstance.js'\n  import { testHasIndexedDB, testHasLocalStorage } from '../../../_utils/testStorage.js'\n  import Tooltip from '../../../_components/Tooltip.html'\n\n  export default {\n    async oncreate () {\n      const params = new URLSearchParams(location.search)\n      const code = params.get('code')\n      if (code) {\n        await handleOauthCode(code)\n      } else {\n        this.set({\n          hasIndexedDB: await testHasIndexedDB(),\n          hasLocalStorage: testHasLocalStorage()\n        })\n      }\n    },\n    components: {\n      SettingsLayout,\n      Tooltip\n    },\n    store: () => store,\n    data: () => ({\n      hasIndexedDB: true,\n      hasLocalStorage: true\n    }),\n    computed: {\n      pageLabel: ({ $isUserLoggedIn }) => $isUserLoggedIn ? \"Add instance\" : \"Log in\"\n    },\n    methods: {\n      onSubmitInstance (event) {\n        event.preventDefault()\n        event.stopPropagation()\n        logInToInstance()\n      }\n    }\n  }\n</script>\n","<Title name={titleName} settingsPage={true} />\n\n  <LazyPage {pageComponent} {params} />\n\n<script>\n  import Title from '../../_components/Title.html'\n  import LazyPage from '../../_components/LazyPage.html'\n  import pageComponent from '../../_pages/settings/instances/add.html'\n\n  export default {\n    components: {\n\n      Title,\n      LazyPage\n    },\n    data: () => ({\n      pageComponent\n    }),\n    computed: {\n      titleName: ({ $isUserLoggedIn }) => $isUserLoggedIn ? \"Add instance\" : \"Log in\"\n    }\n  }\n</script>\n","import {\n  cacheFirstUpdateAfter,\n  cacheFirstUpdateOnlyIfNotInCache\n} from '../_utils/sync.js'\nimport { database } from '../_database/database.js'\nimport { getCustomEmoji } from '../_api/emoji.js'\nimport { store } from '../_store/store.js'\nimport { isEqual } from '../_thirdparty/lodash/objects.js'\n\nasync function syncEmojiForInstance (instanceName, syncMethod) {\n  await syncMethod(\n    () => {\n      const { loggedInInstances } = store.get()\n      const accessToken = loggedInInstances[instanceName].access_token\n      return getCustomEmoji(instanceName, accessToken)\n    },\n    () => database.getCustomEmoji(instanceName),\n    emoji => database.setCustomEmoji(instanceName, emoji),\n    emoji => {\n      const { customEmoji } = store.get()\n      if (!isEqual(customEmoji[instanceName], emoji)) { // avoid triggering updates if nothing's changed\n        customEmoji[instanceName] = emoji\n        store.set({ customEmoji })\n      }\n    }\n  )\n}\n\nexport async function updateCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateAfter)\n}\n\nexport async function setupCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateOnlyIfNotInCache)\n}\n\nexport function insertEmoji (realm, emoji) {\n  const emojiText = emoji.unicode || `:${emoji.name}:`\n  const { composeSelectionStart } = store.get()\n  const idx = composeSelectionStart || 0\n  const oldText = store.getComposeData(realm, 'text') || ''\n  const pre = oldText.substring(0, idx)\n  const post = oldText.substring(idx)\n  const newText = `${pre}${emojiText} ${post}`\n  store.setComposeData(realm, { text: newText })\n}\n","import { auth, basename } from './utils.js'\nimport { DEFAULT_TIMEOUT, get } from '../_utils/ajax.js'\n\nexport function getCustomEmoji (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/custom_emojis`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n","import { get, DEFAULT_TIMEOUT } from '../_utils/ajax.js'\nimport { auth, basename } from './utils.js'\n\nexport function getVerifyCredentials (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/accounts/verify_credentials`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n\nexport function getAccount (instanceName, accessToken, accountId) {\n  const url = `${basename(instanceName)}/api/v1/accounts/${accountId}`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n","export const importDatabase = () => import(\n  '../../_database/databaseApis.js'\n)\n","// All database functions are asynchronous, so we can just proxy here and\n// put an async import of the database, to avoid including it in the main bundle\n// (which doesn't need to run when the user isn't logged in).\n\nimport { importDatabase } from '../_utils/asyncModules/importDatabase.js'\n\nconst handler = {\n  get: function (obj, prop) {\n    return async function (...args) {\n      if (!obj[prop]) {\n        const database = await importDatabase()\n        obj[prop] = database[prop]\n      }\n      return obj[prop].apply(null, args)\n    }\n  }\n}\n\nexport const asyncDatabase = new Proxy({}, handler)\n","// Hit both the cache and the network, setting state for the cached version first,\n// then the network version (as it's assumed to be fresher). Also update the db afterwards.\nexport async function cacheFirstUpdateAfter (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  const networkPromise = networkFetcher() // kick off network request immediately\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  } finally {\n    if (dbResponse) {\n      stateSetter(dbResponse)\n    }\n    const fetchAndUpdatePromise = networkPromise.then(networkResponse => {\n      /* no await */ dbUpdater(networkResponse)\n      stateSetter(networkResponse)\n    })\n    if (!dbResponse) { // no cached result available, await the network\n      await fetchAndUpdatePromise\n    }\n  }\n}\n\n// Try the cache first. If we get a hit, set the state and do nothing. If we don't get a cache hit,\n// then go to the network, update the cache, and set the state.\nexport async function cacheFirstUpdateOnlyIfNotInCache (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  }\n  if (dbResponse) {\n    stateSetter(dbResponse)\n  } else {\n    const networkResponse = await networkFetcher()\n    /* no await */ dbUpdater(networkResponse)\n    stateSetter(networkResponse)\n  }\n}\n"],"names":["SCOPES","DOMAIN_BLOCKS","createKnownError","message","err","Error","knownError","getRedirectUri","location","origin","async","redirectToOauth","instanceNameInSearch","loggedInInstances","store","replace","toLowerCase","Object","keys","includes","instanceHostname","URL","hostname","some","domain","RegExp","test","redirectUri","registrationPromise","instanceName","url","client_name","redirect_uris","scopes","website","timeout","registerApplication","instanceInfo","database","status","instanceData","currentRegisteredInstanceName","currentRegisteredInstance","oauthUrl","clientId","params","client_id","redirect_uri","response_type","scope","generateAuthLink","setTimeout","document","href","registerNewInstance","code","clientSecret","URLSearchParams","client_secret","grant_type","getAccessTokenFromAuthCode","loggedInInstancesInOrder","instanceThemes","push","currentInstance","enableGrayscale","onSubmitInstance","event","preventDefault","stopPropagation","logInToInstanceLoading","logInToInstanceError","console","error","name","navigator","onLine","logInToInstanceErrorForText","logInToInstance","search","get","handleOauthCode","this","set","hasIndexedDB","hasLocalStorage","$logInToInstanceError","$logInToInstanceErrorForText","$instanceNameInSearch","$isUserLoggedIn","pageLabel","$logInToInstanceLoading","pageComponent","titleName","syncEmojiForInstance","syncMethod","accessToken","access_token","getCustomEmoji","emoji","customEmoji","updateCustomEmojiForInstance","setupCustomEmojiForInstance","insertEmoji","realm","emojiText","unicode","composeSelectionStart","idx","oldText","newText","substring","text","getVerifyCredentials","getAccount","accountId","asyncDatabase","Proxy","obj","prop","args","apply","cacheFirstUpdateAfter","networkFetcher","dbFetcher","dbUpdater","stateSetter","networkPromise","dbResponse","fetchAndUpdatePromise","then","networkResponse","cacheFirstUpdateOnlyIfNotInCache"],"sourceRoot":""}