{"version":3,"file":"4970.742cfae2d5d703d639b6.4970.js","mappings":"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","sources":["webpack://semaphore/./src/routes/_database/constants.js","webpack://semaphore/./src/routes/_database/cache.js","webpack://semaphore/./src/routes/_thirdparty/idb-keyval/idb-keyval.js","webpack://semaphore/./src/routes/_database/knownInstances.js","webpack://semaphore/./src/routes/_database/migrations.js","webpack://semaphore/./src/routes/_database/databaseLifecycle.js","webpack://semaphore/./src/routes/_database/helpers.js","webpack://semaphore/./src/routes/_database/keys.js","webpack://semaphore/./src/routes/_database/accounts.js","webpack://semaphore/./src/routes/_database/clear.js","webpack://semaphore/./src/routes/_database/timelines/lookup.js","webpack://semaphore/./src/routes/_database/timelines/cacheStatus.js","webpack://semaphore/./src/routes/_database/utils.js","webpack://semaphore/./src/routes/_database/cleanup.js","webpack://semaphore/./src/routes/_database/timelines/insertion.js","webpack://semaphore/./src/routes/_database/timelines/fetchAccount.js","webpack://semaphore/./src/routes/_database/timelines/fetchStatus.js","webpack://semaphore/./src/routes/_database/timelines/pinnedStatuses.js","webpack://semaphore/./src/routes/_database/timelines/fetchNotification.js","webpack://semaphore/./src/routes/_database/timelines/pagination.js","webpack://semaphore/./src/routes/_database/timelines/getStatusOrNotification.js","webpack://semaphore/./src/routes/_database/timelines/updateStatus.js","webpack://semaphore/./src/routes/_database/timelines/deletion.js","webpack://semaphore/./src/routes/_database/meta.js","webpack://semaphore/./src/routes/_database/relationships.js","webpack://semaphore/./src/routes/_static/share.js","webpack://semaphore/./src/routes/_database/webShare.js","webpack://semaphore/./src/routes/_database/mediaUploadFileCache.js","webpack://semaphore/./src/routes/_static/database.js","webpack://semaphore/./src/routes/_static/timelines.js","webpack://semaphore/./src/routes/_thirdparty/quick-lru/quick-lru.js","webpack://semaphore/./src/routes/_utils/statusIdSorting.js"],"sourcesContent":["export const STATUSES_STORE = 'statuses-v4'\nexport const STATUS_TIMELINES_STORE = 'status_timelines-v4'\nexport const META_STORE = 'meta-v4'\nexport const ACCOUNTS_STORE = 'accounts-v4'\nexport const RELATIONSHIPS_STORE = 'relationships-v4'\nexport const NOTIFICATIONS_STORE = 'notifications-v4'\nexport const NOTIFICATION_TIMELINES_STORE = 'notification_timelines-v4'\nexport const PINNED_STATUSES_STORE = 'pinned_statuses-v4'\nexport const THREADS_STORE = 'threads-v4'\n\nexport const TIMESTAMP = '__semaphore_ts'\nexport const ACCOUNT_ID = '__semaphore_acct_id'\nexport const STATUS_ID = '__semaphore_status_id'\nexport const REBLOG_ID = '__semaphore_reblog_id'\nexport const USERNAME_LOWERCASE = '__semaphore_acct_lc'\n\nexport const DB_VERSION_INITIAL = 9\nexport const DB_VERSION_SEARCH_ACCOUNTS = 10\nexport const DB_VERSION_SNOWFLAKE_IDS = 12 // 11 skipped because of mistake deployed to beta.semaphore.social\n\n// Using an object for these so that unit tests can change them\nexport const DB_VERSION_CURRENT = { version: 12 }\nexport const CURRENT_TIME = { now: () => Date.now() }\n","import { QuickLRU } from '../_thirdparty/quick-lru/quick-lru.js'\n\nexport const statusesCache = {\n  maxSize: 100,\n  caches: {}\n}\nexport const accountsCache = {\n  maxSize: 50,\n  caches: {}\n}\nexport const relationshipsCache = {\n  maxSize: 20,\n  caches: {}\n}\nexport const metaCache = {\n  maxSize: 20,\n  caches: {}\n}\nexport const notificationsCache = {\n  maxSize: 50,\n  caches: {}\n}\n\nif (process.browser && process.env.NODE_ENV !== 'production') {\n  (typeof self !== 'undefined' ? self : window).cacheStats = {\n    statuses: statusesCache,\n    accounts: accountsCache,\n    relationships: relationshipsCache,\n    meta: metaCache,\n    notifications: notificationsCache\n  }\n}\n\nfunction getOrCreateInstanceCache (cache, instanceName) {\n  let cached = cache.caches[instanceName]\n  if (!cached) {\n    cached = cache.caches[instanceName] = new QuickLRU({ maxSize: cache.maxSize })\n  }\n  return cached\n}\n\nexport function clearCache (cache, instanceName) {\n  delete cache.caches[instanceName]\n}\nexport function clearAllCaches (instanceName) {\n  const allCaches = [statusesCache, accountsCache, relationshipsCache, metaCache, notificationsCache]\n  for (const cache of allCaches) {\n    clearCache(cache, instanceName)\n  }\n}\nexport function setInCache (cache, instanceName, key, value) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  return instanceCache.set(key, value)\n}\n\nexport function getInCache (cache, instanceName, key) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  return instanceCache.get(key)\n}\n\nexport function hasInCache (cache, instanceName, key) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  const res = instanceCache.has(key)\n  if (process.env.NODE_ENV !== 'production') {\n    if (res) {\n      cache.hits = (cache.hits || 0) + 1\n    } else {\n      cache.misses = (cache.misses || 0) + 1\n    }\n  }\n  return res\n}\n\nexport function deleteFromCache (cache, instanceName, key) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  instanceCache.delete(key)\n}\n","// Forked from https://github.com/jakearchibald/idb-keyval/commit/ea7d507\n// Adds a function for closing the database, ala https://github.com/jakearchibald/idb-keyval/pull/65\n// Also hooks it into the lifecycle frozen event\nimport { lifecycle } from '../../_utils/lifecycle.js'\n\nclass Store {\n  constructor (dbName = 'keyval-store', storeName = 'keyval') {\n    this.storeName = storeName\n    this._dbName = dbName\n    this._storeName = storeName\n    this._init()\n  }\n\n  _withIDBStore (type, callback) {\n    this._init()\n    return this._dbp.then(db => new Promise((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, type)\n      transaction.oncomplete = () => resolve()\n      transaction.onabort = transaction.onerror = () => reject(transaction.error)\n      callback(transaction.objectStore(this.storeName))\n    }))\n  }\n\n  _init () {\n    if (this._dbp) {\n      return\n    }\n    this._dbp = new Promise((resolve, reject) => {\n      const openreq = indexedDB.open(this._dbName, 1)\n      openreq.onerror = () => reject(openreq.error)\n      openreq.onsuccess = () => resolve(openreq.result)\n      // First time setup: create an empty object store\n      openreq.onupgradeneeded = () => {\n        openreq.result.createObjectStore(this._storeName)\n      }\n    })\n  }\n\n  _close () {\n    this._init()\n    return this._dbp.then(db => {\n      db.close()\n      this._dbp = undefined\n    })\n  }\n}\n\nlet store\n\nfunction getDefaultStore () {\n  if (!store) {\n    store = new Store()\n  }\n  return store\n}\n\nfunction get (key) {\n  const store = getDefaultStore()\n  let req\n  return store._withIDBStore('readonly', store => {\n    req = store.get(key)\n  }).then(() => req.result)\n}\n\nfunction set (key, value) {\n  const store = getDefaultStore()\n  return store._withIDBStore('readwrite', store => {\n    store.put(value, key)\n  })\n}\n\nfunction del (key) {\n  const store = getDefaultStore()\n  return store._withIDBStore('readwrite', store => {\n    store.delete(key)\n  })\n}\n\nfunction clear () {\n  const store = getDefaultStore()\n  return store._withIDBStore('readwrite', store => {\n    store.clear()\n  })\n}\n\nfunction keys () {\n  const store = getDefaultStore()\n  const keys = []\n  return store._withIDBStore('readonly', store => {\n    // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\n    // And openKeyCursor isn't supported by Safari.\n    (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\n      if (!this.result) {\n        return\n      }\n      keys.push(this.result.key)\n      this.result.continue()\n    }\n  }).then(() => keys)\n}\n\nfunction close () {\n  const store = getDefaultStore()\n  return store._close()\n}\n\nif (process.browser) {\n  lifecycle.addEventListener('statechange', async event => {\n    if (event.newState === 'frozen') { // page is frozen, close IDB connections\n      await close()\n      console.log('closed keyval DB')\n    }\n  })\n}\n\nexport { Store, get, set, del, clear, keys, close }\n","import { set, keys, del } from '../_thirdparty/idb-keyval/idb-keyval.js'\n\nconst PREFIX = 'known-instance-'\n\nexport async function getKnownInstances () {\n  return (await keys())\n    .filter(_ => _.startsWith(PREFIX))\n    .map(_ => _.substring(PREFIX.length))\n}\n\nexport async function addKnownInstance (instanceName) {\n  return set(PREFIX + instanceName, true)\n}\n\nexport async function deleteKnownInstance (instanceName) {\n  return del(PREFIX + instanceName)\n}\n","import {\n  ACCOUNTS_STORE, DB_VERSION_SNOWFLAKE_IDS, DB_VERSION_INITIAL,\n  DB_VERSION_SEARCH_ACCOUNTS, META_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE, PINNED_STATUSES_STORE,\n  REBLOG_ID, RELATIONSHIPS_STORE,\n  STATUS_ID,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE, THREADS_STORE,\n  TIMESTAMP, USERNAME_LOWERCASE\n} from './constants.js'\nimport { toReversePaddedBigInt } from '../_utils/statusIdSorting.js'\n\nfunction initialMigration (db, tx, done) {\n  function createObjectStore (name, init, indexes) {\n    const store = init\n      ? db.createObjectStore(name, init)\n      : db.createObjectStore(name)\n    if (indexes) {\n      Object.keys(indexes).forEach(indexKey => {\n        store.createIndex(indexKey, indexes[indexKey])\n      })\n    }\n  }\n\n  createObjectStore(STATUSES_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP,\n    [REBLOG_ID]: REBLOG_ID\n  })\n  createObjectStore(STATUS_TIMELINES_STORE, null, {\n    statusId: ''\n  })\n  createObjectStore(NOTIFICATIONS_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP,\n    [STATUS_ID]: STATUS_ID\n  })\n  createObjectStore(NOTIFICATION_TIMELINES_STORE, null, {\n    notificationId: ''\n  })\n  createObjectStore(ACCOUNTS_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP\n  })\n  createObjectStore(RELATIONSHIPS_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP\n  })\n  createObjectStore(THREADS_STORE, null, {\n    statusId: ''\n  })\n  createObjectStore(PINNED_STATUSES_STORE, null, {\n    statusId: ''\n  })\n  createObjectStore(META_STORE)\n  done()\n}\n\nfunction addSearchAccountsMigration (db, tx, done) {\n  tx.objectStore(ACCOUNTS_STORE)\n    .createIndex(USERNAME_LOWERCASE, USERNAME_LOWERCASE)\n  done()\n}\n\nfunction snowflakeIdsMigration (db, tx, done) {\n  const stores = [STATUS_TIMELINES_STORE, NOTIFICATION_TIMELINES_STORE]\n  let storeDoneCount = 0\n\n  // Here we have to convert the old \"reversePaddedBigInt\" format to the new\n  // one which is compatible with Pleroma-style snowflake IDs.\n  stores.forEach(store => {\n    const objectStore = tx.objectStore(store)\n    const cursor = objectStore.openCursor()\n    cursor.onsuccess = e => {\n      const { result } = e.target\n      if (result) {\n        const { key, value } = result\n        // key is timeline name plus delimiter plus reverse padded big int\n        const newKey = key.split('\\u0000')[0] + '\\u0000' + toReversePaddedBigInt(value)\n\n        objectStore.delete(key).onsuccess = () => {\n          objectStore.add(value, newKey).onsuccess = () => {\n            result.continue()\n          }\n        }\n      } else {\n        if (++storeDoneCount === stores.length) {\n          done()\n        }\n      }\n    }\n  })\n}\n\nexport const migrations = [\n  {\n    version: DB_VERSION_INITIAL,\n    migration: initialMigration\n  },\n  {\n    version: DB_VERSION_SEARCH_ACCOUNTS,\n    migration: addSearchAccountsMigration\n  },\n  {\n    version: DB_VERSION_SNOWFLAKE_IDS,\n    migration: snowflakeIdsMigration\n  }\n]\n","import { DB_VERSION_CURRENT } from './constants.js'\nimport { addKnownInstance, deleteKnownInstance } from './knownInstances.js'\nimport { migrations } from './migrations.js'\nimport { clearAllCaches } from './cache.js'\nimport { lifecycle } from '../_utils/lifecycle.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\nimport { del } from '../_thirdparty/idb-keyval/idb-keyval.js'\n\nconst openReqs = {}\nconst databaseCache = {}\n\nfunction createDatabase (instanceName) {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.open(instanceName, DB_VERSION_CURRENT.version)\n    openReqs[instanceName] = req\n    req.onerror = reject\n    req.onblocked = () => {\n      console.error('idb blocked')\n    }\n    req.onupgradeneeded = (e) => {\n      const db = req.result\n      const tx = e.currentTarget.transaction\n\n      const migrationsToDo = migrations.filter(({ version }) => e.oldVersion < version)\n\n      function doNextMigration () {\n        if (!migrationsToDo.length) {\n          return\n        }\n        const { migration } = migrationsToDo.shift()\n        migration(db, tx, doNextMigration)\n      }\n      doNextMigration()\n    }\n    req.onsuccess = () => resolve(req.result)\n  })\n}\n\nexport async function getDatabase (instanceName) {\n  if (!instanceName) {\n    throw new Error('instanceName is undefined in getDatabase()')\n  }\n  if (!databaseCache[instanceName]) {\n    databaseCache[instanceName] = await createDatabase(instanceName)\n    await addKnownInstance(instanceName)\n  }\n  return databaseCache[instanceName]\n}\n\nexport async function dbPromise (db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(storeName, readOnlyOrReadWrite)\n    const store = typeof storeName === 'string'\n      ? tx.objectStore(storeName)\n      : storeName.map(name => tx.objectStore(name))\n    let res\n    cb(store, (result) => {\n      res = result\n    })\n\n    tx.oncomplete = () => resolve(res)\n    tx.onerror = () => reject(tx.error)\n  })\n}\n\nexport function deleteDatabase (instanceName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    const openReq = openReqs[instanceName]\n    if (openReq && openReq.result) {\n      openReq.result.close()\n    }\n    delete openReqs[instanceName]\n    delete databaseCache[instanceName]\n    const req = indexedDB.deleteDatabase(instanceName)\n    req.onsuccess = () => resolve()\n    req.onerror = () => reject(req.error)\n    req.onblocked = () => console.error(`database ${instanceName} blocked`)\n  }).then(() => deleteKnownInstance(instanceName))\n    .then(() => clearAllCaches(instanceName))\n}\n\nexport function closeDatabase (instanceName) {\n  // close any open requests\n  const openReq = openReqs[instanceName]\n  if (openReq && openReq.result) {\n    openReq.result.close()\n  }\n  delete openReqs[instanceName]\n  delete databaseCache[instanceName]\n  clearAllCaches(instanceName)\n}\n\nif (process.browser) {\n  lifecycle.addEventListener('statechange', event => {\n    if (event.newState === 'frozen') { // page is frozen, close IDB connections\n      Object.keys(openReqs).forEach(instanceName => {\n        closeDatabase(instanceName)\n        console.log('closed instance DBs')\n      })\n    }\n  })\n\n  // Clean up files that Tesseract.js may have stored. Originally we allowed it to store\n  // stuff in IDB, but now we don't.\n  // TODO: we can remove this after it's been deployed for a while\n  scheduleIdleTask(() => del('./eng.traineddata'))\n}\n","import { dbPromise, getDatabase } from './databaseLifecycle.js'\nimport { getInCache, hasInCache, setInCache } from './cache.js'\nimport {\n  ACCOUNT_ID, REBLOG_ID, STATUS_ID, TIMESTAMP, USERNAME_LOWERCASE, CURRENT_TIME\n} from './constants.js'\n\nexport async function getGenericEntityWithId (store, cache, instanceName, id) {\n  if (hasInCache(cache, instanceName, id)) {\n    return getInCache(cache, instanceName, id)\n  }\n  const db = await getDatabase(instanceName)\n  const result = await dbPromise(db, store, 'readonly', (store, callback) => {\n    store.get(id).onsuccess = (e) => callback(e.target.result)\n  })\n  setInCache(cache, instanceName, id, result)\n  return result\n}\n\nexport async function setGenericEntityWithId (store, cache, instanceName, entity) {\n  setInCache(cache, instanceName, entity.id, entity)\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, store, 'readwrite', (store) => {\n    store.put(entity)\n  })\n}\n\nexport function cloneForStorage (obj) {\n  const res = {}\n  const keys = Object.keys(obj)\n  for (const key of keys) {\n    const value = obj[key]\n    // save storage space by skipping nulls, 0s, falses, empty strings, and empty arrays\n    if (!value || (Array.isArray(value) && value.length === 0)) {\n      continue\n    }\n    switch (key) {\n      case 'account':\n        res[ACCOUNT_ID] = value.id\n        break\n      case 'status':\n        res[STATUS_ID] = value.id\n        break\n      case 'reblog':\n        res[REBLOG_ID] = value.id\n        break\n      case 'acct':\n        res[key] = value\n        res[USERNAME_LOWERCASE] = value.toLowerCase()\n        break\n      default:\n        res[key] = value\n        break\n    }\n  }\n  res[TIMESTAMP] = CURRENT_TIME.now()\n  return res\n}\n","import { toReversePaddedBigInt, zeroPad } from '../_utils/statusIdSorting.js'\n\n//\n// timelines\n//\n\nexport function createTimelineId (timeline, id) {\n  // reverse chronological order, prefixed by timeline\n  return timeline + '\\u0000' + toReversePaddedBigInt(id)\n}\n\nexport function createTimelineKeyRange (timeline, maxId) {\n  const negBigInt = maxId && toReversePaddedBigInt(maxId)\n  const start = negBigInt ? (timeline + '\\u0000' + negBigInt) : (timeline + '\\u0000')\n  const end = timeline + '\\u0000\\uffff'\n  return IDBKeyRange.bound(start, end, true, true)\n}\n\n//\n// threads\n//\n\nexport function createThreadId (statusId, i) {\n  return statusId + '\\u0000' + zeroPad(i, 5)\n}\n\nexport function createThreadKeyRange (statusId) {\n  return IDBKeyRange.bound(\n    statusId + '\\u0000',\n    statusId + '\\u0000\\uffff'\n  )\n}\n\n//\n// pinned statues\n//\n\nexport function createPinnedStatusId (accountId, i) {\n  return accountId + '\\u0000' + zeroPad(i, 3)\n}\n\nexport function createPinnedStatusKeyRange (accountId) {\n  return IDBKeyRange.bound(\n    accountId + '\\u0000',\n    accountId + '\\u0000\\uffff'\n  )\n}\n\n//\n// accounts\n//\n\nexport function createAccountUsernamePrefixKeyRange (accountUsernamePrefix) {\n  return IDBKeyRange.bound(\n    accountUsernamePrefix,\n    accountUsernamePrefix + '\\uffff'\n  )\n}\n","import { ACCOUNTS_STORE, USERNAME_LOWERCASE } from './constants.js'\nimport { accountsCache } from './cache.js'\nimport { cloneForStorage, getGenericEntityWithId, setGenericEntityWithId } from './helpers.js'\nimport { dbPromise, getDatabase } from './databaseLifecycle.js'\nimport { createAccountUsernamePrefixKeyRange } from './keys.js'\n\nexport async function getAccount (instanceName, accountId) {\n  return getGenericEntityWithId(ACCOUNTS_STORE, accountsCache, instanceName, accountId)\n}\n\nexport async function setAccount (instanceName, account) {\n  return setGenericEntityWithId(ACCOUNTS_STORE, accountsCache, instanceName, cloneForStorage(account))\n}\n\nexport async function searchAccountsByUsername (instanceName, usernamePrefix, limit) {\n  limit = limit || 20\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, ACCOUNTS_STORE, 'readonly', (accountsStore, callback) => {\n    const keyRange = createAccountUsernamePrefixKeyRange(usernamePrefix.toLowerCase())\n    accountsStore.index(USERNAME_LOWERCASE).getAll(keyRange, limit).onsuccess = e => {\n      callback(e.target.result)\n    }\n  })\n}\n","import { accountsCache, clearCache, metaCache, statusesCache } from './cache.js'\nimport { deleteDatabase } from './databaseLifecycle.js'\n\nexport async function clearDatabaseForInstance (instanceName) {\n  clearCache(statusesCache, instanceName)\n  clearCache(accountsCache, instanceName)\n  clearCache(metaCache, instanceName)\n  await deleteDatabase(instanceName)\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport { STATUSES_STORE, STATUS_ID, REBLOG_ID, NOTIFICATIONS_STORE } from '../constants.js'\n\nexport async function getReblogsForStatus (instanceName, id) {\n  const db = await getDatabase(instanceName)\n  await dbPromise(db, STATUSES_STORE, 'readonly', (statusesStore, callback) => {\n    statusesStore.index(REBLOG_ID).getAll(IDBKeyRange.only(id)).onsuccess = e => {\n      callback(e.target.result)\n    }\n  })\n}\n\nexport async function getNotificationIdsForStatuses (instanceName, statusIds) {\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, NOTIFICATIONS_STORE, 'readonly', (notificationsStore, callback) => {\n    const res = []\n    callback(res)\n    statusIds.forEach(statusId => {\n      const req = notificationsStore.index(STATUS_ID).getAllKeys(IDBKeyRange.only(statusId))\n      req.onsuccess = e => {\n        for (const id of e.target.result) {\n          res.push(id)\n        }\n      }\n    })\n  })\n}\n","import {\n  accountsCache, setInCache, statusesCache\n} from '../cache.js'\n\nexport function cacheStatus (status, instanceName) {\n  setInCache(statusesCache, instanceName, status.id, status)\n  setInCache(accountsCache, instanceName, status.account.id, status.account)\n  if (status.reblog) {\n    setInCache(accountsCache, instanceName, status.reblog.account.id, status.reblog.account)\n  }\n}\n","export function deleteAll (store, index, keyRange) {\n  index.getAllKeys(keyRange).onsuccess = e => {\n    for (const result of e.target.result) {\n      store.delete(result)\n    }\n  }\n}\n","import { dbPromise, getDatabase } from './databaseLifecycle.js'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE,\n  PINNED_STATUSES_STORE,\n  RELATIONSHIPS_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE,\n  TIMESTAMP\n} from './constants.js'\nimport { debounce } from '../_thirdparty/lodash/timers.js'\nimport { mark, stop } from '../_utils/marks.js'\nimport { deleteAll } from './utils.js'\nimport { createPinnedStatusKeyRange, createThreadKeyRange } from './keys.js'\nimport { getKnownInstances } from './knownInstances.js'\nimport { noop } from '../_utils/lodash-lite.js'\nimport { CLEANUP_DELAY, CLEANUP_TIME_AGO } from '../_static/database.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\n\nconst BATCH_SIZE = 20\n\nfunction batchedGetAll (callGetAll, callback) {\n  function nextBatch () {\n    callGetAll().onsuccess = function (e) {\n      const results = e.target.result\n      callback(results)\n      if (results.length) {\n        nextBatch()\n      }\n    }\n  }\n  nextBatch()\n}\n\nfunction cleanupStatuses (statusesStore, statusTimelinesStore, threadsStore, cutoff) {\n  batchedGetAll(\n    () => statusesStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(statusId => {\n        statusesStore.delete(statusId)\n        deleteAll(\n          statusTimelinesStore,\n          statusTimelinesStore.index('statusId'),\n          IDBKeyRange.only(statusId)\n        )\n        deleteAll(\n          threadsStore,\n          threadsStore,\n          createThreadKeyRange(statusId)\n        )\n      })\n    }\n  )\n}\n\nfunction cleanupNotifications (notificationsStore, notificationTimelinesStore, cutoff) {\n  batchedGetAll(\n    () => notificationsStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(notificationId => {\n        notificationsStore.delete(notificationId)\n        deleteAll(\n          notificationTimelinesStore,\n          notificationTimelinesStore.index('notificationId'),\n          IDBKeyRange.only(notificationId)\n        )\n      })\n    }\n  )\n}\n\nfunction cleanupAccounts (accountsStore, pinnedStatusesStore, cutoff) {\n  batchedGetAll(\n    () => accountsStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(accountId => {\n        accountsStore.delete(accountId)\n        deleteAll(\n          pinnedStatusesStore,\n          pinnedStatusesStore,\n          createPinnedStatusKeyRange(accountId)\n        )\n      })\n    }\n  )\n}\n\nfunction cleanupRelationships (relationshipsStore, cutoff) {\n  batchedGetAll(\n    () => relationshipsStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(relationshipId => {\n        relationshipsStore.delete(relationshipId)\n      })\n    }\n  )\n}\n\nexport async function cleanup (instanceName) {\n  console.log('cleanup', instanceName)\n  mark(`cleanup:${instanceName}`)\n  const db = await getDatabase(instanceName)\n  const storeNames = [\n    STATUSES_STORE,\n    STATUS_TIMELINES_STORE,\n    NOTIFICATIONS_STORE,\n    NOTIFICATION_TIMELINES_STORE,\n    ACCOUNTS_STORE,\n    RELATIONSHIPS_STORE,\n    THREADS_STORE,\n    PINNED_STATUSES_STORE\n  ]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [\n      statusesStore,\n      statusTimelinesStore,\n      notificationsStore,\n      notificationTimelinesStore,\n      accountsStore,\n      relationshipsStore,\n      threadsStore,\n      pinnedStatusesStore\n    ] = stores\n\n    const cutoff = Date.now() - CLEANUP_TIME_AGO\n\n    cleanupStatuses(statusesStore, statusTimelinesStore, threadsStore, cutoff)\n    cleanupNotifications(notificationsStore, notificationTimelinesStore, cutoff)\n    cleanupAccounts(accountsStore, pinnedStatusesStore, cutoff)\n    cleanupRelationships(relationshipsStore, cutoff)\n  })\n  stop(`cleanup:${instanceName}`)\n}\n\nfunction doCleanup (instanceName) {\n  scheduleIdleTask(() => cleanup(instanceName))\n}\n\nasync function scheduledCleanup () {\n  console.log('scheduledCleanup')\n  const knownInstances = await getKnownInstances()\n  for (const instance of knownInstances) {\n    doCleanup(instance)\n  }\n}\n\n// we have unit tests that test indexedDB; we don't want this thing to run forever\nexport const scheduleCleanup = process.browser ? debounce(scheduledCleanup, CLEANUP_DELAY) : noop\n","import { difference } from '../../_thirdparty/lodash/objects.js'\nimport { times } from '../../_utils/lodash-lite.js'\nimport { cloneForStorage } from '../helpers.js'\nimport { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport { accountsCache, notificationsCache, setInCache, statusesCache } from '../cache.js'\nimport { scheduleCleanup } from '../cleanup.js'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE\n} from '../constants.js'\nimport {\n  createThreadId,\n  createThreadKeyRange,\n  createTimelineId\n} from '../keys.js'\nimport { cacheStatus } from './cacheStatus.js'\n\nexport function putStatus (statusesStore, status) {\n  statusesStore.put(cloneForStorage(status))\n}\n\nexport function putAccount (accountsStore, account) {\n  accountsStore.put(cloneForStorage(account))\n}\n\nexport function putNotification (notificationsStore, notification) {\n  notificationsStore.put(cloneForStorage(notification))\n}\n\nexport function storeAccount (accountsStore, account) {\n  putAccount(accountsStore, account)\n}\n\nexport function storeStatus (statusesStore, accountsStore, status) {\n  putStatus(statusesStore, status)\n  putAccount(accountsStore, status.account)\n  if (status.reblog) {\n    putStatus(statusesStore, status.reblog)\n    putAccount(accountsStore, status.reblog.account)\n  }\n}\n\nexport function storeNotification (notificationsStore, statusesStore, accountsStore, notification) {\n  if (notification.status) {\n    storeStatus(statusesStore, accountsStore, notification.status)\n  }\n  storeAccount(accountsStore, notification.account)\n  putNotification(notificationsStore, notification)\n}\n\nasync function insertTimelineNotifications (instanceName, timeline, notifications) {\n  for (const notification of notifications) {\n    setInCache(notificationsCache, instanceName, notification.id, notification)\n    setInCache(accountsCache, instanceName, notification.account.id, notification.account)\n    if (notification.status) {\n      setInCache(statusesCache, instanceName, notification.status.id, notification.status)\n    }\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [NOTIFICATION_TIMELINES_STORE, NOTIFICATIONS_STORE, ACCOUNTS_STORE, STATUSES_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [timelineStore, notificationsStore, accountsStore, statusesStore] = stores\n    for (const notification of notifications) {\n      storeNotification(notificationsStore, statusesStore, accountsStore, notification)\n      timelineStore.put(notification.id, createTimelineId(timeline, notification.id))\n    }\n  })\n}\n\nasync function insertTimelineStatuses (instanceName, timeline, statuses) {\n  for (const status of statuses) {\n    cacheStatus(status, instanceName)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [STATUS_TIMELINES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [timelineStore, statusesStore, accountsStore] = stores\n    for (const status of statuses) {\n      storeStatus(statusesStore, accountsStore, status)\n      timelineStore.put(status.id, createTimelineId(timeline, status.id))\n    }\n  })\n}\n\nasync function insertStatusThread (instanceName, statusId, statuses) {\n  for (const status of statuses) {\n    cacheStatus(status, instanceName)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [THREADS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [threadsStore, statusesStore, accountsStore] = stores\n    threadsStore.getAllKeys(createThreadKeyRange(statusId)).onsuccess = e => {\n      const existingKeys = e.target.result\n      const newKeys = times(statuses.length, i => createThreadId(statusId, i))\n      const keysToDelete = difference(existingKeys, newKeys)\n      for (const key of keysToDelete) {\n        threadsStore.delete(key)\n      }\n    }\n    statuses.forEach((otherStatus, i) => {\n      storeStatus(statusesStore, accountsStore, otherStatus)\n      threadsStore.put(otherStatus.id, createThreadId(statusId, i))\n    })\n  })\n}\n\nexport async function insertTimelineItems (instanceName, timeline, timelineItems) {\n  console.log('insertTimelineItems', instanceName, timeline, timelineItems)\n  /* no await */ scheduleCleanup()\n  if (timeline === 'notifications' || timeline === 'notifications/mentions') {\n    return insertTimelineNotifications(instanceName, timeline, timelineItems)\n  } else if (timeline.startsWith('status/')) {\n    const statusId = timeline.split('/').slice(-1)[0]\n    return insertStatusThread(instanceName, statusId, timelineItems)\n  } else {\n    return insertTimelineStatuses(instanceName, timeline, timelineItems)\n  }\n}\n\nexport async function insertStatus (instanceName, status) {\n  cacheStatus(status, instanceName)\n  const db = await getDatabase(instanceName)\n  await dbPromise(db, [STATUSES_STORE, ACCOUNTS_STORE], 'readwrite', ([statusesStore, accountsStore]) => {\n    storeStatus(statusesStore, accountsStore, status)\n  })\n}\n","export function fetchAccount (accountsStore, id, callback) {\n  accountsStore.get(id).onsuccess = e => {\n    callback(e.target.result)\n  }\n}\n","import { fetchAccount } from './fetchAccount.js'\nimport { ACCOUNT_ID, REBLOG_ID } from '../constants.js'\n\nexport function fetchStatus (statusesStore, accountsStore, id, callback) {\n  statusesStore.get(id).onsuccess = e => {\n    const status = e.target.result\n    callback(status)\n    if (!status) {\n      return\n    }\n    fetchAccount(accountsStore, status[ACCOUNT_ID], account => {\n      status.account = account\n    })\n    if (status[REBLOG_ID]) {\n      fetchStatus(statusesStore, accountsStore, status[REBLOG_ID], reblog => {\n        status.reblog = reblog\n      })\n    }\n  }\n}\n","import { cacheStatus } from './cacheStatus.js'\nimport { getDatabase, dbPromise } from '../databaseLifecycle.js'\nimport { PINNED_STATUSES_STORE, STATUSES_STORE, ACCOUNTS_STORE } from '../constants.js'\nimport { createPinnedStatusId, createPinnedStatusKeyRange } from '../keys.js'\nimport { storeStatus } from './insertion.js'\nimport { fetchStatus } from './fetchStatus.js'\n\nexport async function insertPinnedStatuses (instanceName, accountId, statuses) {\n  for (const status of statuses) {\n    cacheStatus(status, instanceName)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [PINNED_STATUSES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [pinnedStatusesStore, statusesStore, accountsStore] = stores\n\n    const keyRange = createPinnedStatusKeyRange(accountId)\n    pinnedStatusesStore.getAll(keyRange).onsuccess = e => {\n      // if there was e.g. 1 pinned status before and 2 now, then we need to delete the old one\n      const existingPinnedStatuses = e.target.result\n      for (let i = statuses.length; i < existingPinnedStatuses.length; i++) {\n        pinnedStatusesStore.delete(createPinnedStatusKeyRange(accountId, i))\n      }\n      statuses.forEach((status, i) => {\n        storeStatus(statusesStore, accountsStore, status)\n        pinnedStatusesStore.put(status.id, createPinnedStatusId(accountId, i))\n      })\n    }\n  })\n}\n\nexport async function getPinnedStatuses (instanceName, accountId) {\n  const storeNames = [PINNED_STATUSES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [pinnedStatusesStore, statusesStore, accountsStore] = stores\n    const keyRange = createPinnedStatusKeyRange(accountId)\n    pinnedStatusesStore.getAll(keyRange).onsuccess = e => {\n      const pinnedResults = e.target.result\n      const res = new Array(pinnedResults.length)\n      pinnedResults.forEach((statusId, i) => {\n        fetchStatus(statusesStore, accountsStore, statusId, status => {\n          res[i] = status\n        })\n      })\n      callback(res)\n    }\n  })\n}\n","import { fetchAccount } from './fetchAccount.js'\nimport { ACCOUNT_ID, STATUS_ID } from '../constants.js'\nimport { fetchStatus } from './fetchStatus.js'\n\nexport function fetchNotification (notificationsStore, statusesStore, accountsStore, id, callback) {\n  notificationsStore.get(id).onsuccess = e => {\n    const notification = e.target.result\n    callback(notification)\n    if (!notification) {\n      return\n    }\n    fetchAccount(accountsStore, notification[ACCOUNT_ID], account => {\n      notification.account = account\n    })\n    if (notification[STATUS_ID]) {\n      fetchStatus(statusesStore, accountsStore, notification[STATUS_ID], status => {\n        notification.status = status\n      })\n    }\n  }\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE\n} from '../constants.js'\nimport {\n  createThreadKeyRange,\n  createTimelineKeyRange\n} from '../keys.js'\nimport { fetchStatus } from './fetchStatus.js'\nimport { fetchNotification } from './fetchNotification.js'\nimport { TIMELINE_BATCH_SIZE } from '../../_static/timelines.js'\n\nasync function getNotificationTimeline (instanceName, timeline, maxId, limit) {\n  const storeNames = [NOTIFICATION_TIMELINES_STORE, NOTIFICATIONS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [timelineStore, notificationsStore, statusesStore, accountsStore] = stores\n    const keyRange = createTimelineKeyRange(timeline, maxId)\n\n    timelineStore.getAll(keyRange, limit).onsuccess = e => {\n      const timelineResults = e.target.result\n      const res = new Array(timelineResults.length)\n      timelineResults.forEach((notificationId, i) => {\n        fetchNotification(notificationsStore, statusesStore, accountsStore, notificationId, notification => {\n          res[i] = notification\n        })\n      })\n      callback(res)\n    }\n  })\n}\n\nasync function getStatusTimeline (instanceName, timeline, maxId, limit) {\n  const storeNames = [STATUS_TIMELINES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [timelineStore, statusesStore, accountsStore] = stores\n    const getReq = timelineStore.getAll(createTimelineKeyRange(timeline, maxId), limit)\n    getReq.onsuccess = e => {\n      const timelineResults = e.target.result\n      const res = new Array(timelineResults.length)\n      timelineResults.forEach((statusId, i) => {\n        fetchStatus(statusesStore, accountsStore, statusId, status => {\n          res[i] = status\n        })\n      })\n      callback(res)\n    }\n  })\n}\n\nasync function getStatusThread (instanceName, statusId) {\n  const storeNames = [THREADS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [threadsStore, statusesStore, accountsStore] = stores\n    const keyRange = createThreadKeyRange(statusId)\n    threadsStore.getAll(keyRange).onsuccess = e => {\n      const thread = e.target.result\n      if (thread.length) {\n        const res = new Array(thread.length)\n        callback(res)\n        thread.forEach((otherStatusId, i) => {\n          fetchStatus(statusesStore, accountsStore, otherStatusId, status => {\n            res[i] = status\n          })\n        })\n      } else {\n        // thread not cached; just make a \"fake\" thread with only one status in it\n        fetchStatus(statusesStore, accountsStore, statusId, status => {\n          const res = [status]\n          callback(res)\n        })\n      }\n    }\n  })\n}\n\nexport async function getTimeline (instanceName, timeline, maxId, limit) {\n  maxId = maxId || null\n  limit = limit || TIMELINE_BATCH_SIZE\n  if (timeline === 'notifications' || timeline === 'notifications/mentions') {\n    return getNotificationTimeline(instanceName, timeline, maxId, limit)\n  } else if (timeline.startsWith('status/')) {\n    const statusId = timeline.split('/').slice(-1)[0]\n    return getStatusThread(instanceName, statusId)\n  } else {\n    return getStatusTimeline(instanceName, timeline, maxId, limit)\n  }\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport { getInCache, hasInCache, notificationsCache, setInCache, statusesCache } from '../cache.js'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATIONS_STORE,\n  STATUSES_STORE\n} from '../constants.js'\nimport { fetchStatus } from './fetchStatus.js'\nimport { fetchNotification } from './fetchNotification.js'\n\nexport async function getStatus (instanceName, id) {\n  if (hasInCache(statusesCache, instanceName, id)) {\n    return getInCache(statusesCache, instanceName, id)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [STATUSES_STORE, ACCOUNTS_STORE]\n  const result = await dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [statusesStore, accountsStore] = stores\n    fetchStatus(statusesStore, accountsStore, id, callback)\n  })\n  setInCache(statusesCache, instanceName, id, result)\n  return result\n}\n\nexport async function getNotification (instanceName, id) {\n  if (hasInCache(notificationsCache, instanceName, id)) {\n    return getInCache(notificationsCache, instanceName, id)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [NOTIFICATIONS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const result = await dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [notificationsStore, statusesStore, accountsStore] = stores\n    fetchNotification(notificationsStore, statusesStore, accountsStore, id, callback)\n  })\n  setInCache(notificationsCache, instanceName, id, result)\n  return result\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport { getInCache, hasInCache, statusesCache } from '../cache.js'\nimport { STATUSES_STORE } from '../constants.js'\nimport { cacheStatus } from './cacheStatus.js'\nimport { putStatus } from './insertion.js'\nimport { cloneForStorage } from '../helpers.js'\n\n//\n// update statuses\n//\n\nasync function doUpdateStatus (instanceName, statusId, updateFunc) {\n  const db = await getDatabase(instanceName)\n  if (hasInCache(statusesCache, instanceName, statusId)) {\n    const status = getInCache(statusesCache, instanceName, statusId)\n    updateFunc(status)\n    cacheStatus(status, instanceName)\n  }\n  return dbPromise(db, STATUSES_STORE, 'readwrite', (statusesStore) => {\n    statusesStore.get(statusId).onsuccess = e => {\n      const status = e.target.result\n      updateFunc(status)\n      putStatus(statusesStore, status)\n    }\n  })\n}\n\nexport async function setStatusFavorited (instanceName, statusId, favorited) {\n  return doUpdateStatus(instanceName, statusId, status => {\n    const delta = (favorited ? 1 : 0) - (status.favourited ? 1 : 0)\n    status.favourited = favorited\n    status.favourites_count = (status.favourites_count || 0) + delta\n  })\n}\n\nexport async function setStatusReblogged (instanceName, statusId, reblogged) {\n  return doUpdateStatus(instanceName, statusId, status => {\n    const delta = (reblogged ? 1 : 0) - (status.reblogged ? 1 : 0)\n    status.reblogged = reblogged\n    status.reblogs_count = (status.reblogs_count || 0) + delta\n  })\n}\n\nexport async function setStatusPinned (instanceName, statusId, pinned) {\n  return doUpdateStatus(instanceName, statusId, status => {\n    status.pinned = pinned\n  })\n}\n\nexport async function setStatusMuted (instanceName, statusId, muted) {\n  return doUpdateStatus(instanceName, statusId, status => {\n    status.muted = muted\n  })\n}\n\nexport async function setStatusBookmarked (instanceName, statusId, bookmarked) {\n  return doUpdateStatus(instanceName, statusId, status => {\n    status.bookmarked = bookmarked\n  })\n}\n\n// For the full list, see https://docs.joinmastodon.org/methods/statuses/#edit\nconst PROPS_THAT_CAN_BE_EDITED = ['content', 'spoiler_text', 'sensitive', 'language', 'media_ids', 'poll']\n\nexport async function updateStatus (instanceName, newStatus) {\n  const clonedNewStatus = cloneForStorage(newStatus)\n  return doUpdateStatus(instanceName, newStatus.id, status => {\n    // We can't use a simple Object.assign() to merge because a prop might have been deleted\n    for (const prop of PROPS_THAT_CAN_BE_EDITED) {\n      if (!(prop in clonedNewStatus)) {\n        delete status[prop]\n      } else {\n        status[prop] = clonedNewStatus[prop]\n      }\n    }\n  })\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle.js'\nimport {\n  deleteFromCache, notificationsCache,\n  statusesCache\n} from '../cache.js'\nimport {\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE, PINNED_STATUSES_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE\n} from '../constants.js'\nimport {\n  createThreadKeyRange\n} from '../keys.js'\nimport { deleteAll } from '../utils.js'\n\nexport async function deleteStatusesAndNotifications (instanceName, statusIds, notificationIds) {\n  for (const statusId of statusIds) {\n    deleteFromCache(statusesCache, instanceName, statusId)\n  }\n  for (const notificationId of notificationIds) {\n    deleteFromCache(notificationsCache, instanceName, notificationId)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [\n    STATUSES_STORE,\n    STATUS_TIMELINES_STORE,\n    NOTIFICATIONS_STORE,\n    NOTIFICATION_TIMELINES_STORE,\n    PINNED_STATUSES_STORE,\n    THREADS_STORE\n  ]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [\n      statusesStore,\n      statusTimelinesStore,\n      notificationsStore,\n      notificationTimelinesStore,\n      pinnedStatusesStore,\n      threadsStore\n    ] = stores\n\n    function deleteStatus (statusId) {\n      statusesStore.delete(statusId)\n      deleteAll(\n        pinnedStatusesStore,\n        pinnedStatusesStore.index('statusId'),\n        IDBKeyRange.only(statusId)\n      )\n      deleteAll(\n        statusTimelinesStore,\n        statusTimelinesStore.index('statusId'),\n        IDBKeyRange.only(statusId)\n      )\n      deleteAll(\n        threadsStore,\n        threadsStore.index('statusId'),\n        IDBKeyRange.only(statusId)\n      )\n      deleteAll(\n        threadsStore,\n        threadsStore,\n        createThreadKeyRange(statusId)\n      )\n    }\n\n    function deleteNotification (notificationId) {\n      notificationsStore.delete(notificationId)\n      deleteAll(\n        notificationTimelinesStore,\n        notificationTimelinesStore.index('notificationId'),\n        IDBKeyRange.only(notificationId)\n      )\n    }\n\n    for (const statusId of statusIds) {\n      deleteStatus(statusId)\n    }\n    for (const notificationId of notificationIds) {\n      deleteNotification(notificationId)\n    }\n  })\n}\n","import { dbPromise, getDatabase } from './databaseLifecycle.js'\nimport { META_STORE } from './constants.js'\nimport { metaCache, hasInCache, getInCache, setInCache } from './cache.js'\n\nasync function getMetaProperty (instanceName, key) {\n  if (hasInCache(metaCache, instanceName, key)) {\n    return getInCache(metaCache, instanceName, key)\n  }\n  const db = await getDatabase(instanceName)\n  const result = await dbPromise(db, META_STORE, 'readonly', (store, callback) => {\n    store.get(key).onsuccess = (e) => {\n      callback(e.target.result)\n    }\n  })\n  setInCache(metaCache, instanceName, key, result)\n  return result\n}\n\nasync function setMetaProperty (instanceName, key, value) {\n  setInCache(metaCache, instanceName, key, value)\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, META_STORE, 'readwrite', (store) => {\n    store.put(value, key)\n  })\n}\n\nexport async function getInstanceVerifyCredentials (instanceName) {\n  return getMetaProperty(instanceName, 'verifyCredentials')\n}\n\nexport async function setInstanceVerifyCredentials (instanceName, value) {\n  return setMetaProperty(instanceName, 'verifyCredentials', value)\n}\n\nexport async function getInstanceInfo (instanceName) {\n  return getMetaProperty(instanceName, 'instance')\n}\n\nexport async function setInstanceInfo (instanceName, value) {\n  return setMetaProperty(instanceName, 'instance', value)\n}\n\nexport async function getLists (instanceName) {\n  return getMetaProperty(instanceName, 'lists')\n}\n\nexport async function setLists (instanceName, value) {\n  return setMetaProperty(instanceName, 'lists', value)\n}\n\nexport async function getCustomEmoji (instanceName) {\n  return getMetaProperty(instanceName, 'customEmoji')\n}\n\nexport async function setCustomEmoji (instanceName, value) {\n  return setMetaProperty(instanceName, 'customEmoji', value)\n}\n\nexport async function getFollowRequestCount (instanceName) {\n  return getMetaProperty(instanceName, 'followRequestCount')\n}\n\nexport async function setFollowRequestCount (instanceName, value) {\n  return setMetaProperty(instanceName, 'followRequestCount', value)\n}\n\nexport async function getFilters (instanceName) {\n  return getMetaProperty(instanceName, 'filters')\n}\n\nexport async function setFilters (instanceName, value) {\n  return setMetaProperty(instanceName, 'filters', value)\n}\n","import { cloneForStorage, getGenericEntityWithId, setGenericEntityWithId } from './helpers.js'\nimport { RELATIONSHIPS_STORE } from './constants.js'\nimport { relationshipsCache } from './cache.js'\n\nexport async function getRelationship (instanceName, accountId) {\n  return getGenericEntityWithId(RELATIONSHIPS_STORE, relationshipsCache, instanceName, accountId)\n}\n\nexport async function setRelationship (instanceName, relationship) {\n  return setGenericEntityWithId(RELATIONSHIPS_STORE, relationshipsCache, instanceName, cloneForStorage(relationship))\n}\n","export const WEB_SHARE_TARGET_DATA_IDB_KEY = 'web-share-data'\n","import { get, set, close, del } from '../_thirdparty/idb-keyval/idb-keyval.js'\nimport { WEB_SHARE_TARGET_DATA_IDB_KEY } from '../_static/share.js'\n\nexport function deleteWebShareData () {\n  return del(WEB_SHARE_TARGET_DATA_IDB_KEY)\n}\n\nexport function setWebShareData (data) {\n  return set(WEB_SHARE_TARGET_DATA_IDB_KEY, data)\n}\n\nexport function getWebShareData () {\n  return get(WEB_SHARE_TARGET_DATA_IDB_KEY)\n}\n\nexport function closeKeyValIDBConnection () {\n  return close()\n}\n","// Keep an LRU cache of recently-uploaded files for OCR.\n// We keep them in IDB to avoid tainted canvas errors after a refresh.\n// https://github.com/nolanlawson/pinafore/issues/1901\n\nimport { get, set, keys, del } from '../_thirdparty/idb-keyval/idb-keyval.js'\n\nconst PREFIX = 'media-cache-'\nconst DELIMITER = '-cache-'\nconst LIMIT = 4 // you can upload 4 images per post, this seems reasonable despite cross-instance usage\nexport const DELETE_AFTER = 604800000 // 7 days\n\nlet deleteAfter = DELETE_AFTER\n\nfunction keyToData (key) {\n  key = key.substring(PREFIX.length)\n  const index = key.indexOf(DELIMITER)\n  // avoiding str.split() to not have to worry about ids containing the delimiter string somehow\n  return [key.substring(0, index), key.substring(index + DELIMITER.length)]\n}\n\nfunction dataToKey (timestamp, id) {\n  return `${PREFIX}${timestamp}${DELIMITER}${id}`\n}\n\nasync function getAllKeys () {\n  return (await keys()).filter(key => key.startsWith(PREFIX)).sort()\n}\n\nexport async function getCachedMediaFile (id) {\n  const allKeys = await getAllKeys()\n\n  for (const key of allKeys) {\n    const otherId = keyToData(key)[1]\n    if (id === otherId) {\n      return get(key)\n    }\n  }\n}\n\nexport async function setCachedMediaFile (id, file) {\n  const allKeys = await getAllKeys()\n\n  if (allKeys.map(keyToData).map(_ => _[1]).includes(id)) {\n    return // do nothing, it's already in there\n  }\n\n  while (allKeys.length >= LIMIT) {\n    // already sorted in chronological order, so delete the oldest\n    await del(allKeys.shift())\n  }\n\n  // delete anything that's too old, while we're at it\n  for (const key of allKeys) {\n    const timestamp = keyToData(key)[0]\n    if (Date.now() - Date.parse(timestamp) >= deleteAfter) {\n      await del(key)\n    }\n  }\n\n  const key = dataToKey(new Date().toISOString(), id)\n\n  await set(key, file)\n}\n\nexport async function deleteCachedMediaFile (id) {\n  const allKeys = await getAllKeys()\n\n  for (const key of allKeys) {\n    const otherId = keyToData(key)[1]\n    if (otherId === id) {\n      await del(key)\n    }\n  }\n}\n\n// The following are only used in tests\n\nexport async function getAllCachedFileIds () {\n  return (await getAllKeys()).map(keyToData).map(_ => _[1])\n}\n\nexport function setDeleteCachedMediaFilesAfter (newDeleteAfter) {\n  deleteAfter = newDeleteAfter\n}\n","export const CLEANUP_TIME_AGO = 5 * 24 * 60 * 60 * 1000 // five days ago\nexport const CLEANUP_DELAY = 5 * 60 * 1000 // five minutes\n","export const TIMELINE_BATCH_SIZE = 20\n\nexport const timelines = {\n  home: { name: 'home', label: \"Home\" },\n  local: { name: 'local', label: \"Local\" },\n  federated: { name: 'federated', label: \"Federated\" }\n}\n","// Forked from https://github.com/sindresorhus/quick-lru/blob/16d15d470a8eb87c2a7dd5b80892d9b74f1acd3c/index.js\n// Adds the ability to listen for 'evict' events using an EventEmitter, also removes some unused code\n\nimport eventsLightPackage from 'events-light'\nconst { EventEmitter } = eventsLightPackage\n\nexport class QuickLRU extends EventEmitter {\n  constructor (options = {}) {\n    super()\n    if (!(options.maxSize && options.maxSize > 0)) {\n      throw new TypeError('`maxSize` must be a number greater than 0')\n    }\n\n    this.maxSize = options.maxSize\n    this.cache = new Map()\n    this.oldCache = new Map()\n    this._size = 0\n  }\n\n  _set (key, value) {\n    this.cache.set(key, value)\n    this._size++\n\n    if (this._size >= this.maxSize) {\n      this._size = 0\n      if (this.listenerCount('evict')) {\n        for (const key of this.oldCache.keys()) {\n          if (!this.cache.has(key)) {\n            this.emit('evict', this.oldCache.get(key), key)\n          }\n        }\n      }\n      this.oldCache = this.cache\n      this.cache = new Map()\n    }\n  }\n\n  get (key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key)\n    }\n\n    if (this.oldCache.has(key)) {\n      const value = this.oldCache.get(key)\n      this.oldCache.delete(key)\n      this._set(key, value)\n      return value\n    }\n  }\n\n  set (key, value) {\n    if (this.cache.has(key)) {\n      this.cache.set(key, value)\n    } else {\n      this._set(key, value)\n    }\n\n    return this\n  }\n\n  has (key) {\n    return this.cache.has(key) || this.oldCache.has(key)\n  }\n\n  // unused\n  // peek (key) {\n  //   if (this.cache.has(key)) {\n  //     return this.cache.get(key)\n  //   }\n  //\n  //   if (this.oldCache.has(key)) {\n  //     return this.oldCache.get(key)\n  //   }\n  // }\n\n  delete (key) {\n    const deleted = this.cache.delete(key)\n    if (deleted) {\n      this._size--\n    }\n\n    return this.oldCache.delete(key) || deleted\n  }\n\n  clear () {\n    this.cache.clear()\n    this.oldCache.clear()\n    this._size = 0\n  }\n\n  getAllKeys () {\n    const set = new Set()\n    for (const key of this.cache.keys()) {\n      set.add(key)\n    }\n    for (const key of this.oldCache.keys()) {\n      set.add(key)\n    }\n    return set\n  }\n\n  // unused\n  // * keys() {\n  //   for (const [key] of this) {\n  //     yield key;\n  //   }\n  // }\n  //\n  // * values() {\n  //   for (const [, value] of this) {\n  //     yield value;\n  //   }\n  // }\n  //\n  // * [Symbol.iterator]() {\n  //   for (const item of this.cache) {\n  //     yield item;\n  //   }\n  //\n  //   for (const item of this.oldCache) {\n  //     const [key] = item;\n  //     if (!this.cache.has(key)) {\n  //       yield item;\n  //     }\n  //   }\n  // }\n  //\n  // get size () {\n  //   let oldCacheSize = 0\n  //   for (const key of this.oldCache.keys()) {\n  //     if (!this.cache.has(key)) {\n  //       oldCacheSize++\n  //     }\n  //   }\n  //\n  //   return this._size + oldCacheSize\n  // }\n}\n","// Pleroma uses base62 IDs, Mastodon uses 0-9 big ints encoded as strings.\n// Using base62 for both works, since the first 10 characters of base62\n// are 0-9.\n\nimport { padStart } from './lodash-lite.js'\n\n// Pleroma uses the 0-9A-Za-z alphabet for base62, which is the same as ASCII, which\n// is the same as JavaScript sort order and IndexedDB order.\nconst MIN_CHAR_CODE = 48 // '0'.charCodeAt(0)\nconst MAX_CHAR_CODE = 122 // 'z'.charCodeAt(0)\nconst MAX_ID_LENGTH = 30 // assume that Mastodon/Pleroma IDs won't get any bigger than this\n\nexport function zeroPad (str, toSize) {\n  return padStart(str, toSize, '0')\n}\n\nexport function toPaddedBigInt (id) {\n  return zeroPad(id, MAX_ID_LENGTH)\n}\n\nexport function toReversePaddedBigInt (id) {\n  const padded = toPaddedBigInt(id)\n  let reversed = ''\n  for (let i = 0; i < padded.length; i++) {\n    const charCode = padded.charCodeAt(i)\n    const inverseCharCode = MIN_CHAR_CODE + MAX_CHAR_CODE - charCode\n    reversed += String.fromCharCode(inverseCharCode)\n  }\n  return reversed\n}\n\nexport function compareTimelineItemSummaries (left, right) {\n  const leftPadded = toPaddedBigInt(left.id)\n  const rightPadded = toPaddedBigInt(right.id)\n  return leftPadded < rightPadded ? -1 : leftPadded === rightPadded ? 0 : 1\n}\n"],"names":["STATUSES_STORE","STATUS_TIMELINES_STORE","META_STORE","ACCOUNTS_STORE","RELATIONSHIPS_STORE","NOTIFICATIONS_STORE","NOTIFICATION_TIMELINES_STORE","PINNED_STATUSES_STORE","THREADS_STORE","TIMESTAMP","ACCOUNT_ID","STATUS_ID","REBLOG_ID","USERNAME_LOWERCASE","DB_VERSION_CURRENT","CURRENT_TIME","Date","now","statusesCache","maxSize","caches","accountsCache","relationshipsCache","metaCache","notificationsCache","getOrCreateInstanceCache","cache","instanceName","cached","clearCache","clearAllCaches","allCaches","setInCache","key","value","set","getInCache","get","hasInCache","has","deleteFromCache","delete","Store","constructor","dbName","storeName","this","_dbName","_storeName","_init","_withIDBStore","type","callback","_dbp","then","db","Promise","resolve","reject","transaction","oncomplete","onabort","onerror","error","objectStore","openreq","indexedDB","open","onsuccess","result","onupgradeneeded","createObjectStore","_close","close","undefined","store","getDefaultStore","req","put","del","keys","openKeyCursor","openCursor","call","push","continue","lifecycle","async","event","newState","PREFIX","migrations","version","migration","tx","done","name","init","indexes","Object","forEach","indexKey","createIndex","keyPath","statusId","notificationId","stores","storeDoneCount","e","target","newKey","split","add","length","openReqs","databaseCache","getDatabase","Error","onblocked","console","currentTarget","migrationsToDo","filter","oldVersion","doNextMigration","shift","createDatabase","addKnownInstance","dbPromise","readOnlyOrReadWrite","cb","map","res","deleteDatabase","openReq","deleteKnownInstance","getGenericEntityWithId","id","setGenericEntityWithId","entity","cloneForStorage","obj","Array","isArray","toLowerCase","createTimelineId","timeline","createTimelineKeyRange","maxId","negBigInt","start","end","IDBKeyRange","bound","createThreadId","i","createThreadKeyRange","createPinnedStatusKeyRange","accountId","getAccount","setAccount","account","searchAccountsByUsername","usernamePrefix","limit","accountsStore","keyRange","accountUsernamePrefix","index","getAll","clearDatabaseForInstance","getReblogsForStatus","statusesStore","only","getNotificationIdsForStatuses","statusIds","notificationsStore","getAllKeys","cacheStatus","status","reblog","closeDatabase","scheduleIdleTask","deleteAll","batchedGetAll","callGetAll","nextBatch","results","cleanup","storeNames","statusTimelinesStore","notificationTimelinesStore","relationshipsStore","threadsStore","pinnedStatusesStore","cutoff","upperBound","cleanupStatuses","cleanupNotifications","cleanupAccounts","relationshipId","cleanupRelationships","s","doCleanup","scheduleCleanup","knownInstances","_","startsWith","substring","getKnownInstances","instance","putStatus","putAccount","storeStatus","storeNotification","notification","storeAccount","putNotification","insertTimelineItems","timelineItems","notifications","timelineStore","insertTimelineNotifications","statuses","existingKeys","newKeys","keysToDelete","otherStatus","insertStatusThread","slice","insertTimelineStatuses","insertStatus","fetchAccount","fetchStatus","insertPinnedStatuses","existingPinnedStatuses","createPinnedStatusId","getPinnedStatuses","pinnedResults","fetchNotification","getTimeline","timelineResults","getNotificationTimeline","thread","otherStatusId","getStatusThread","getStatusTimeline","getStatus","getNotification","doUpdateStatus","updateFunc","setStatusFavorited","favorited","delta","favourited","favourites_count","setStatusReblogged","reblogged","reblogs_count","setStatusPinned","pinned","setStatusMuted","muted","setStatusBookmarked","bookmarked","PROPS_THAT_CAN_BE_EDITED","updateStatus","newStatus","clonedNewStatus","prop","deleteStatusesAndNotifications","notificationIds","deleteStatus","deleteNotification","getMetaProperty","setMetaProperty","getInstanceVerifyCredentials","setInstanceVerifyCredentials","getInstanceInfo","setInstanceInfo","getLists","setLists","getCustomEmoji","setCustomEmoji","getFollowRequestCount","setFollowRequestCount","getFilters","setFilters","getRelationship","setRelationship","relationship","WEB_SHARE_TARGET_DATA_IDB_KEY","deleteWebShareData","setWebShareData","data","getWebShareData","closeKeyValIDBConnection","DELIMITER","DELETE_AFTER","deleteAfter","keyToData","indexOf","sort","getCachedMediaFile","allKeys","setCachedMediaFile","file","includes","timestamp","parse","dataToKey","toISOString","deleteCachedMediaFile","getAllCachedFileIds","setDeleteCachedMediaFilesAfter","newDeleteAfter","CLEANUP_TIME_AGO","CLEANUP_DELAY","TIMELINE_BATCH_SIZE","timelines","home","label","local","federated","EventEmitter","QuickLRU","options","super","TypeError","Map","oldCache","_size","_set","listenerCount","emit","deleted","clear","Set","zeroPad","str","toSize","toPaddedBigInt","toReversePaddedBigInt","padded","reversed","inverseCharCode","MIN_CHAR_CODE","charCodeAt","String","fromCharCode","compareTimelineItemSummaries","left","right","leftPadded","rightPadded"],"sourceRoot":""}