{"version":3,"file":"1170.a1a34d2819c76262ed6b.1170.js","mappings":"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","sources":["webpack://semaphore/./src/routes/_components/radio/RadioGroup.html","webpack://semaphore/./src/routes/_components/radio/RadioGroupButton.html","webpack://semaphore/./src/routes/_api/utils.js","webpack://semaphore/./src/routes/_utils/asyncModules/importDatabase.js","webpack://semaphore/./src/routes/_database/asyncDatabase.js","webpack://semaphore/./src/routes/_utils/ajax.js","webpack://semaphore/./src/routes/_utils/sync.js"],"sourcesContent":["<!-- Modeled after https://www.w3.org/TR/2016/WD-wai-aria-practices-1.1-20160317/examples/radio/radio.html -->\n<div class=\"radio-group {className}\"\n     role=\"radiogroup\"\n     aria-label={label}\n     aria-owns={ariaOwns}\n     on:keydown=\"onKeyDown(event)\"\n     ref:radiogroup\n>\n  <slot></slot>\n</div>\n<script>\n  import { times } from '../../_utils/lodash-lite.js'\n\n  export default {\n    methods: {\n      onKeyDown (e) {\n        // ArrowUp and ArrowDown should change the focused/checked radio button per\n        // https://www.w3.org/TR/2016/WD-wai-aria-practices-1.1-20160317/examples/radio/radio.html\n        const { key, target } = e\n        if (!['ArrowUp', 'ArrowDown'].includes(key)) {\n          return\n        }\n        if (!target.classList.contains('radio-group-button')) {\n          return\n        }\n        const buttons = Array.from(this.refs.radiogroup.getElementsByClassName('radio-group-button'))\n        const len = buttons.length\n        const index = Math.max(0, buttons.findIndex(button => button.getAttribute('aria-checked') === 'true'))\n        const newIndex = (len + (index + (key === 'ArrowUp' ? -1 : 1))) % len // increment/decrement and wrap around\n        buttons[newIndex].focus()\n        buttons[newIndex].click()\n        e.preventDefault()\n        e.stopPropagation()\n      }\n    },\n    data: () => ({\n      className: ''\n    }),\n    computed: {\n      ariaOwns: ({ length, id }) => (\n        times(length, index => `radio-group-button-${id}-${index}`).join(' ')\n      )\n    }\n  }\n</script>\n","<button id=\"radio-group-button-{id}-{index}\"\n        class=\"radio-group-button {checked ? 'checked' : 'not-checked'} {className}\"\n        role=\"radio\"\n        aria-label={label}\n        title={label}\n        aria-checked={checked}\n        on:click\n>\n  <slot></slot>\n</button>\n<style>\n  .radio-group-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border: 0;\n    background: none;\n  }\n  .radio-group-button:hover {\n    background: none;\n  }\n  .radio-group-button:active {\n    background: none;\n  }\n</style>\n<script>\n  export default {\n    data: () => ({\n      className: ''\n    })\n  }\n</script>\n","function targetIsLocalhost (instanceName) {\n  return instanceName.startsWith('localhost:') || instanceName.startsWith('127.0.0.1:')\n}\n\nexport function basename (instanceName) {\n  if (targetIsLocalhost(instanceName)) {\n    return `http://${instanceName}`\n  }\n  return `https://${instanceName}`\n}\n\nexport function auth (accessToken) {\n  return {\n    Authorization: `Bearer ${accessToken}`\n  }\n}\n","export const importDatabase = () => import(\n  '../../_database/databaseApis.js'\n)\n","// All database functions are asynchronous, so we can just proxy here and\n// put an async import of the database, to avoid including it in the main bundle\n// (which doesn't need to run when the user isn't logged in).\n\nimport { importDatabase } from '../_utils/asyncModules/importDatabase.js'\n\nconst handler = {\n  get: function (obj, prop) {\n    return async function (...args) {\n      if (!obj[prop]) {\n        const database = await importDatabase()\n        obj[prop] = database[prop]\n      }\n      return obj[prop].apply(null, args)\n    }\n  }\n}\n\nexport const asyncDatabase = new Proxy({}, handler)\n","export const DEFAULT_TIMEOUT = 20000\nexport const MEDIA_WRITE_TIMEOUT = 90000 // media uploads can take awhile\nexport const WRITE_TIMEOUT = 45000 // allow more time if the user did a write action\n\nfunction fetchWithTimeout (url, fetchOptions, timeout) {\n  return new Promise((resolve, reject) => {\n    fetch(url, fetchOptions).then(resolve, reject)\n    setTimeout(() => reject(new Error(`Timed out after ${timeout / 1000} seconds`)), timeout)\n  })\n}\n\nfunction makeFetchOptions (method, headers, options) {\n  const res = {\n    method,\n    headers: Object.assign(headers || {}, {\n      Accept: 'application/json'\n    })\n  }\n  if (options && options.signal) {\n    res.signal = options.signal\n  }\n  return res\n}\n\nasync function throwErrorIfInvalidResponse (response) {\n  if (response.status >= 300) {\n    const err = new Error('Request failed: ' + response.status)\n    err.status = response.status\n    throw err\n  }\n  const json = await response.json()\n  if (response.status >= 200 && response.status < 300) {\n    return { json, headers: response.headers }\n  }\n  if (json && json.error) {\n    throw new Error(response.status + ': ' + json.error)\n  }\n  throw new Error('Request failed: ' + response.status)\n}\n\nasync function _fetch (url, fetchOptions, options) {\n  let response\n  if (options && options.timeout) {\n    response = await fetchWithTimeout(url, fetchOptions, options.timeout)\n  } else {\n    response = await fetch(url, fetchOptions)\n  }\n  return throwErrorIfInvalidResponse(response)\n}\n\nasync function _putOrPostOrPatch (method, url, body, headers, options) {\n  const fetchOptions = makeFetchOptions(method, headers, options)\n  if (body) {\n    if (body instanceof FormData || body instanceof URLSearchParams) {\n      fetchOptions.body = body\n    } else {\n      fetchOptions.body = JSON.stringify(body)\n      fetchOptions.headers['Content-Type'] = 'application/json'\n    }\n  }\n  return _fetch(url, fetchOptions, options)\n}\n\nexport async function put (url, body, headers, options) {\n  return (await _putOrPostOrPatch('PUT', url, body, headers, options)).json\n}\n\nexport async function post (url, body, headers, options) {\n  return (await _putOrPostOrPatch('POST', url, body, headers, options)).json\n}\n\nexport async function patch (url, body, headers, options) {\n  return (await _putOrPostOrPatch('PATCH', url, body, headers, options)).json\n}\n\nexport async function get (url, headers, options) {\n  return (await _fetch(url, makeFetchOptions('GET', headers, options), options)).json\n}\n\n/** @returns {json, headers} */\nexport async function getWithHeaders (url, headers, options) {\n  return _fetch(url, makeFetchOptions('GET', headers, options), options)\n}\n\nexport async function del (url, headers, options) {\n  return (await _fetch(url, makeFetchOptions('DELETE', headers, options), options)).json\n}\n\nexport function paramsString (paramsObject) {\n  let res = ''\n  let count = -1\n  Object.keys(paramsObject).forEach(key => {\n    const value = paramsObject[key]\n    if (Array.isArray(value)) { // rails convention for encoding multiple values\n      for (const item of value) {\n        res += (++count > 0 ? '&' : '') + encodeURIComponent(key) + '[]=' + encodeURIComponent(item)\n      }\n    } else {\n      res += (++count > 0 ? '&' : '') + encodeURIComponent(key) + '=' + encodeURIComponent(value)\n    }\n  })\n  return res\n}\n","// Hit both the cache and the network, setting state for the cached version first,\n// then the network version (as it's assumed to be fresher). Also update the db afterwards.\nexport async function cacheFirstUpdateAfter (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  const networkPromise = networkFetcher() // kick off network request immediately\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  } finally {\n    if (dbResponse) {\n      stateSetter(dbResponse)\n    }\n    const fetchAndUpdatePromise = networkPromise.then(networkResponse => {\n      /* no await */ dbUpdater(networkResponse)\n      stateSetter(networkResponse)\n    })\n    if (!dbResponse) { // no cached result available, await the network\n      await fetchAndUpdatePromise\n    }\n  }\n}\n\n// Try the cache first. If we get a hit, set the state and do nothing. If we don't get a cache hit,\n// then go to the network, update the cache, and set the state.\nexport async function cacheFirstUpdateOnlyIfNotInCache (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  }\n  if (dbResponse) {\n    stateSetter(dbResponse)\n  } else {\n    const networkResponse = await networkFetcher()\n    /* no await */ dbUpdater(networkResponse)\n    stateSetter(networkResponse)\n  }\n}\n"],"names":["onKeyDown","e","key","target","includes","classList","contains","buttons","Array","from","this","refs","radiogroup","getElementsByClassName","len","length","newIndex","Math","max","findIndex","button","getAttribute","focus","click","preventDefault","stopPropagation","className","event","label","ariaOwns","id","index","join","checked","basename","instanceName","startsWith","targetIsLocalhost","auth","accessToken","Authorization","asyncDatabase","Proxy","get","obj","prop","async","args","database","apply","DEFAULT_TIMEOUT","MEDIA_WRITE_TIMEOUT","WRITE_TIMEOUT","makeFetchOptions","method","headers","options","res","Object","assign","Accept","signal","_fetch","url","fetchOptions","response","timeout","Promise","resolve","reject","fetch","then","setTimeout","Error","fetchWithTimeout","status","err","json","error","throwErrorIfInvalidResponse","_putOrPostOrPatch","body","FormData","URLSearchParams","JSON","stringify","put","post","getWithHeaders","del","paramsString","paramsObject","count","keys","forEach","value","isArray","item","encodeURIComponent","cacheFirstUpdateAfter","networkFetcher","dbFetcher","dbUpdater","stateSetter","networkPromise","dbResponse","console","fetchAndUpdatePromise","networkResponse","cacheFirstUpdateOnlyIfNotInCache"],"sourceRoot":""}