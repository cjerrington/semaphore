{"version":3,"file":"6949.5bd884d1c3e383836fb0.6949.js","mappings":"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","sources":["webpack://semaphore/./node_modules/promise-worker/index.js","webpack://semaphore/./src/routes/_workers/blurhash.js","webpack://semaphore/./src/routes/_utils/blurhash.js","webpack://semaphore/./src/routes/_static/blurhash.js","webpack://semaphore/./src/routes/_actions/rehydrateStatusOrNotification.js","webpack://semaphore/./src/routes/_utils/statusHtmlToPlainText.js"],"sourcesContent":["'use strict'\n\nvar messageIds = 0\n\nfunction onMessage (self, e) {\n  var message = e.data\n  if (!Array.isArray(message) || message.length < 2) {\n    // Ignore - this message is not for us.\n    return\n  }\n  var messageId = message[0]\n  var error = message[1]\n  var result = message[2]\n\n  var callback = self._callbacks[messageId]\n\n  if (!callback) {\n    // Ignore - user might have created multiple PromiseWorkers.\n    // This message is not for us.\n    return\n  }\n\n  delete self._callbacks[messageId]\n  callback(error, result)\n}\n\nfunction PromiseWorker (worker) {\n  var self = this\n  self._worker = worker\n  self._callbacks = {}\n\n  worker.addEventListener('message', function (e) {\n    onMessage(self, e)\n  })\n}\n\nPromiseWorker.prototype.postMessage = function (userMessage) {\n  var self = this\n  var messageId = messageIds++\n\n  var messageToSend = [messageId, userMessage]\n\n  return new Promise(function (resolve, reject) {\n    self._callbacks[messageId] = function (error, result) {\n      if (error) {\n        return reject(new Error(error.message))\n      }\n      resolve(result)\n    }\n\n    /* istanbul ignore if */\n    if (typeof self._worker.controller !== 'undefined') {\n      // service worker, use MessageChannels because e.source is broken in Chrome < 51:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=543198\n      var channel = new MessageChannel()\n      channel.port1.onmessage = function (e) {\n        onMessage(self, e)\n      }\n      self._worker.controller.postMessage(messageToSend, [channel.port2])\n    } else {\n      // web worker\n      self._worker.postMessage(messageToSend)\n    }\n  })\n}\n\nmodule.exports = PromiseWorker\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"blurhash.ef9e7ca2b2b022bba07d.blurhash.js\");\n}\n","import BlurhashWorker from '../_workers/blurhash.js'\nimport PromiseWorker from 'promise-worker'\nimport { BLURHASH_RESOLUTION as RESOLUTION } from '../_static/blurhash.js'\nimport { QuickLRU } from '../_thirdparty/quick-lru/quick-lru.js'\n\n// A timeline will typically show 20-30 articles at once in the virtual list. The maximum number\n// of sensitive images per article is 4. 30*4=120, so this is a very conservative number.\n// Blurhash blobs seem to range from ~1.2-2kB, so this cache could grow to about 2kB*150=300kB max.\nconst cache = new QuickLRU({ maxSize: 150 })\n\nlet worker\nlet canvas\nlet canvasContext2D\n\ncache.on('evict', (evictedUrl, blurhash) => {\n  console.log('evicted URL', evictedUrl, 'with blurhash', blurhash)\n  URL.revokeObjectURL(evictedUrl)\n})\n\nexport function init () {\n  worker = worker || new PromiseWorker(new BlurhashWorker())\n}\n\nfunction initCanvas () {\n  if (!canvas) {\n    canvas = document.createElement('canvas')\n    canvas.height = RESOLUTION\n    canvas.width = RESOLUTION\n    canvasContext2D = canvas.getContext('2d')\n  }\n}\n\n// canvas is the backup if we can't use OffscreenCanvas\nasync function decodeUsingCanvas (imageData) {\n  initCanvas()\n  canvasContext2D.putImageData(imageData, 0, 0)\n  const blob = await new Promise(resolve => canvas.toBlob(resolve))\n  return URL.createObjectURL(blob)\n}\n\nasync function decodeWithoutCache (blurhash) {\n  init()\n  const { decoded, imageData } = await worker.postMessage(blurhash)\n  if (decoded) {\n    return decoded\n  }\n  return decodeUsingCanvas(imageData)\n}\n\nexport async function decode (blurhash) {\n  let result = cache.get(blurhash)\n  if (!result) {\n    result = await decodeWithoutCache(blurhash)\n    cache.set(blurhash, result)\n  }\n  return result\n}\n","export const BLURHASH_RESOLUTION = 32\n","import { get } from '../_utils/lodash-lite.js'\nimport { mark, stop } from '../_utils/marks.js'\nimport { decode as decodeBlurhash, init as initBlurhash } from '../_utils/blurhash.js'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask.js'\nimport { statusHtmlToPlainText } from '../_utils/statusHtmlToPlainText.js'\n\nfunction getActualStatus (statusOrNotification) {\n  return get(statusOrNotification, ['status']) ||\n    get(statusOrNotification, ['notification', 'status'])\n}\n\nexport function prepareToRehydrate () {\n  // start the blurhash worker a bit early to save time\n  try {\n    initBlurhash()\n  } catch (err) {\n    console.error('could not start blurhash worker', err)\n  }\n}\n\nasync function decodeAllBlurhashes (statusOrNotification) {\n  const status = getActualStatus(statusOrNotification)\n  if (!status) {\n    return\n  }\n  const mediaWithBlurhashes = get(status, ['media_attachments'], [])\n    .concat(get(status, ['reblog', 'media_attachments'], []))\n    .filter(_ => _.blurhash)\n  if (mediaWithBlurhashes.length) {\n    mark(`decodeBlurhash-${status.id}`)\n    await Promise.all(mediaWithBlurhashes.map(async media => {\n      try {\n        media.decodedBlurhash = await decodeBlurhash(media.blurhash)\n      } catch (err) {\n        console.warn('Could not decode blurhash, ignoring', err)\n      }\n    }))\n    stop(`decodeBlurhash-${status.id}`)\n  }\n}\n\nasync function calculatePlainTextContent (statusOrNotification) {\n  const status = getActualStatus(statusOrNotification)\n  if (!status) {\n    return\n  }\n  const originalStatus = status.reblog ? status.reblog : status\n  const content = originalStatus.content || ''\n  const mentions = originalStatus.mentions || []\n  // Calculating the plaintext from the HTML is a non-trivial operation, so we might\n  // as well do it in advance, while blurhash is being decoded on the worker thread.\n  await new Promise(resolve => {\n    scheduleIdleTask(() => {\n      originalStatus.plainTextContent = statusHtmlToPlainText(content, mentions)\n      resolve()\n    })\n  })\n}\n\n// Do stuff that we need to do when the status or notification is fetched from the database,\n// like calculating the blurhash or calculating the plain text content\nexport async function rehydrateStatusOrNotification (statusOrNotification) {\n  await Promise.all([\n    decodeAllBlurhashes(statusOrNotification),\n    calculatePlainTextContent(statusOrNotification)\n  ])\n}\n","import { mark, stop } from './marks.js'\nimport { massageStatusPlainText } from './massageStatusPlainText.js'\n\nconst domParser = process.browser && new DOMParser()\n\n// mentions like \"@foo\" have to be expanded to \"@foo@example.com\"\nfunction massageMentions (doc, mentions) {\n  const anchors = doc.querySelectorAll('a.mention')\n  for (let i = 0; i < anchors.length; i++) {\n    const anchor = anchors[i]\n    const href = anchor.getAttribute('href')\n    const mention = mentions.find(mention => mention.url === href)\n    if (mention) {\n      anchor.innerText = `@${mention.acct}`\n    }\n  }\n}\n\n// paragraphs should be separated by double newlines\n// single <br/>s should become single newlines\nfunction innerTextRetainingNewlines (doc) {\n  let res = ''\n  const paragraphs = doc.querySelectorAll('p')\n  for (let i = 0; i < paragraphs.length; i++) {\n    const paragraph = paragraphs[i]\n    const brs = paragraph.querySelectorAll('br')\n    for (let j = 0; j < brs.length; j++) {\n      const br = brs[j]\n      br.parentNode.replaceChild(doc.createTextNode('\\n'), br)\n    }\n    res += (i > 0 ? '\\n\\n' : '') + paragraph.textContent\n  }\n  return res\n}\n\nexport function statusHtmlToPlainText (html, mentions) {\n  if (!html) {\n    return ''\n  }\n  mark('statusHtmlToPlainText')\n  html = massageStatusPlainText(html)\n  const doc = domParser.parseFromString(html, 'text/html')\n  massageMentions(doc, mentions)\n  const res = innerTextRetainingNewlines(doc)\n  stop('statusHtmlToPlainText')\n  return res\n}\n"],"names":["messageIds","onMessage","self","e","message","data","Array","isArray","length","messageId","error","result","callback","_callbacks","PromiseWorker","worker","this","_worker","addEventListener","prototype","postMessage","userMessage","messageToSend","Promise","resolve","reject","Error","controller","channel","MessageChannel","port1","onmessage","port2","module","exports","Worker_fn","Worker","cache","maxSize","canvas","canvasContext2D","init","async","decodeUsingCanvas","imageData","document","createElement","height","width","getContext","putImageData","blob","toBlob","URL","createObjectURL","decode","blurhash","get","decoded","decodeWithoutCache","set","on","evictedUrl","revokeObjectURL","getActualStatus","statusOrNotification","prepareToRehydrate","err","console","decodeAllBlurhashes","status","mediaWithBlurhashes","concat","filter","_","id","all","map","media","decodedBlurhash","warn","s","calculatePlainTextContent","originalStatus","reblog","content","mentions","scheduleIdleTask","plainTextContent","statusHtmlToPlainText","rehydrateStatusOrNotification","domParser","DOMParser","html","doc","parseFromString","anchors","querySelectorAll","i","anchor","href","getAttribute","mention","find","url","innerText","acct","massageMentions","res","paragraphs","paragraph","brs","j","br","parentNode","replaceChild","createTextNode","textContent","innerTextRetainingNewlines"],"sourceRoot":""}